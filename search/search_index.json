{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"README","text":"CodeSurvey <p> GitHub - Documentation </p> <p>CodeSurvey is a framework and tool to survey code repositories for language feature usage, library usage, and more:</p> <ul> <li>Survey a specific set of repositories, or randomly sample   repositories from services like GitHub</li> <li>Built-in support for analyzing Python code; extensible to support   any language</li> <li>Write simple Python functions to define the code features you want   to survey; record arbitrary details of feature occurrences</li> <li>Supports parallelizization of repository downloading and analysis   across multiple processes</li> <li>Logging and progress tracking to monitor your survey as it runs</li> <li>Inspect the results as Python objects, or in an sqlite database</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install codesurvey\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>The <code>CodeSurvey</code> class can easily be configured to run a survey, such as to measure how often the <code>math</code> module is used in a random set of recently updated Python repositories from GitHub:</p> <pre><code>from codesurvey import CodeSurvey\nfrom codesurvey.sources import GithubSampleSource\nfrom codesurvey.analyzers.python import PythonAstAnalyzer\nfrom codesurvey.analyzers.python.features import py_module_feature_finder\n\n# Define a FeatureFinder to look for the `math` module in Python code\nhas_math = py_module_feature_finder('math', modules=['math'])\n\n# Configure the survey\nsurvey = CodeSurvey(\n    db_filepath='math_survey.sqlite3',\n    sources=[\n        GithubSampleSource(language='python'),\n    ],\n    analyzers=[\n        PythonAstAnalyzer(\n            feature_finders=[\n                has_math,\n            ],\n        ),\n    ],\n    max_workers=5,\n)\n\n# Run the survey on 10 repositories\nsurvey.run(max_repos=10)\n\n# Report on the results\nrepo_features = survey.get_repo_features(feature_names=['math'])\nrepo_count_with_math = sum([\n    1 for repo_feature in repo_features if\n    repo_feature.occurrence_count &gt; 0\n])\nprint(f'{repo_count_with_math} out of {len(repo_features)} repos use math')\n</code></pre> <p></p> <ul> <li>For more Sources of repositories, see Source   docs</li> <li>For more Analyzers and FeatureFinders, see Analyzer   docs</li> <li>For more options and methods for inspecting results, see   <code>CodeSurvey</code> docs</li> <li>For details on directly inspecting the sqlite database of survey   results see Database docs</li> <li>More examples can be found in   examples</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<ul> <li>Install Poetry dependencies with <code>make deps</code></li> <li>Documentation:<ul> <li>Run local server: <code>make docs-serve</code></li> <li>Build docs: <code>make docs-build</code></li> <li>Deploy docs to GitHub Pages: <code>make docs-github</code></li> <li>Docstring style follows the Google style guide</li> </ul> </li> </ul>"},{"location":"#todo","title":"TODO","text":"<ul> <li>Add unit tests</li> </ul>"},{"location":"core/","title":"Core CodeSurvey","text":""},{"location":"core/#codesurvey.CodeSurvey","title":"<code>codesurvey.CodeSurvey</code>","text":"<p>Primary interface for running surveys and inspecting their results.</p> <p>A CodeSurvey is instantiated with a set of Sources to be surveyed and a set of Analyzers to count the occurrences of features within them. Each Source may fetch multiple Repos (e.g. a project directory, a git repository), each of which may contain multiple Codes (e.g. a source-code file) to be analyzed. Each Analyzer will be configured to identify a particular set of features within each Code.</p> <p>Additional arguments can be passed to <code>__init__()</code> to control persistent storage, parallelism, and other options.</p> <p>The survey can be executed with <code>run()</code>, which accepts options that determine the stopping condition for the survey. Multiple calls to <code>run()</code> will extend the results of the survey.</p> <p><code>get_repo_features()</code>, <code>get_code_features()</code>, and <code>get_survey_tree()</code> can be used to inspect the results of the survey.</p> <p>Previous survey results can be loaded for inspection specifying the same <code>db_filepath</code> used for previous survey run(s).</p> Source code in <code>codesurvey/core.py</code> <pre><code>class CodeSurvey:\n\"\"\"Primary interface for running surveys and inspecting their results.\n\n    A CodeSurvey is instantiated with a set of\n    [Sources](sources/core.md) to be surveyed and a set of\n    [Analyzers](analyzers/core.md) to count the occurrences of\n    *features* within them. Each Source may fetch multiple *Repos*\n    (e.g. a project directory, a git repository), each of which may\n    contain multiple *Codes* (e.g. a source-code file) to be analyzed.\n    Each Analyzer will be configured to identify a particular set of\n    *features* within each Code.\n\n    Additional arguments can be passed to\n    [`__init__()`][codesurvey.CodeSurvey.__init__] to control\n    persistent storage, parallelism, and other options.\n\n    The survey can be executed with\n    [`run()`][codesurvey.CodeSurvey.run], which accepts options that\n    determine the stopping condition for the survey. Multiple calls to\n    [`run()`][codesurvey.CodeSurvey.run] will extend the results of\n    the survey.\n\n    [`get_repo_features()`][codesurvey.CodeSurvey.get_repo_features],\n    [`get_code_features()`][codesurvey.CodeSurvey.get_code_features],\n    and [`get_survey_tree()`][codesurvey.CodeSurvey.get_survey_tree]\n    can be used to inspect the results of the survey.\n\n    Previous survey results can be loaded for inspection specifying\n    the same `db_filepath` used for previous survey run(s).\n\n    \"\"\"\n\n    def __init__(self, *,\n                 sources: Sequence[Source],\n                 analyzers: Sequence[Analyzer],\n                 db_filepath: str = ':memory:',\n                 max_workers: Optional[int] = 1,\n                 continue_on_failure: bool = True,\n                 save_code_features: bool = True,\n                 save_occurrences: bool = True,\n                 use_saved_features: bool = True):\n\"\"\"\n        Args:\n            sources: Sources from which to fetch Repos of Codes\n                to survey. If multiple Sources are provided, Repo fetching\n                will cycle through them in a round-robin fashion.\n            analyzers: Analyzers to identify features in fetched code.\n            db_filepath: Path to an sqlite database file for persisting survey\n                results. Creates a new sqlite database if the path does not\n                exist. Defaults to a non-persistent in-memory database.\n            max_workers: The maximum number of parallel worker processes for\n                fetching Repos from Sources and executing Analyzers. Defaults\n                to a single worker.\n            continue_on_failure: If `True`, exceptions raised by Sources and\n                Analyzers will be logged, but will not halt the survey.\n            save_code_features: If `True`, features of individual Codes will be\n                retained in the survey database. Otherwise, Code features will\n                be deleted once they have been used to compute aggregate\n                features of its respective Repo.\n            save_occurrences: If `True`, occurrence objects returned by\n                FeatureFinders will be saved in the survey database.\n            use_saved_features: If `True`, re-use saved features from an\n                Analyzer for a Code when they already exist in the survey\n                database. Otherwise, reapply all Analyzers to all Codes.\n\n        Raises:\n            ValueError: Invalid survey configuration was specified.\n\n        \"\"\"\n        duplicate_source_names = get_duplicates([source.name for source in sources])\n        if duplicate_source_names:\n            duplicate_sources_str = ', '.join(duplicate_source_names)\n            raise ValueError(('Cannot instantiate CodeSurvey with duplicate '\n                              f'source names: {duplicate_sources_str}. '\n                              'Please set a unique name for each source.'))\n        self.sources = {source.name: source for source in sources}\n\n        duplicate_analyzer_names = get_duplicates([analyzer.name for analyzer in analyzers])\n        if duplicate_analyzer_names:\n            duplicate_analyzers_str = ', '.join(duplicate_analyzer_names)\n            raise ValueError(('Cannot instantiate CodeSurvey with duplicate '\n                              f'analyzer names: {duplicate_analyzers_str}. '\n                              'Please set a unique name for each analyzer.'))\n        self.analyzers = {analyzer.name: analyzer for analyzer in analyzers}\n\n        self.analyzer_features = {analyzer.name: analyzer.get_feature_names()\n                                  for analyzer in analyzers}\n        self.db_filepath = db_filepath\n        self.max_workers = max_workers or os.cpu_count() or 1\n        self.continue_on_failure = continue_on_failure\n        self.save_code_features = save_code_features\n        self.save_occurrences = save_occurrences\n        self.use_saved_features = use_saved_features\n\n        self._runner = CodeSurveyRunner(self)\n\n    def get_db(self):\n\"\"\"Returns the Database that persists survey results.\"\"\"\n        return Database(self.db_filepath)\n\n    def run(self, *,\n            max_repos: Optional[int] = None,\n            max_codes: Optional[int] = None,\n            disable_progress: bool = False,\n            progress_analyzer_features: Optional[Mapping[str, Sequence[str]]] = None):\n\"\"\"Runs the survey by fetching code from sources and applying analyzers.\n\n        If neither of the `max_repos` nor `max_codes` stopping\n        conditions is specified, the survey will continue running\n        until a `KeyboardInterrupt` exception.\n\n        Args:\n            max_repos: If specified, the run will stop after analysing this\n                many Repos.\n            max_codes: If specified, the run will stop after analysing this\n                many Codes.\n            disable_progress: If `True`, do not display tqdm progress bars\n                counting Repos and Codes analyzed.\n            progress_analyzer_features: Mapping of analyzer names to sequences\n                of feature names for which progress trackers should be\n                displayed to count Repos found with those features. Defaults\n                to all features, but disables feature progress trackers with\n                a warning when there are more than 10 features.\n\n        \"\"\"\n        self._runner.run(\n            max_repos=max_repos,\n            max_codes=max_codes,\n            disable_progress=disable_progress,\n            progress_analyzer_features=progress_analyzer_features,\n        )\n\n    def get_repo_features(self, *,\n                          source_names: Optional[Sequence[str]] = None,\n                          analyzer_names: Optional[Sequence[str]] = None,\n                          feature_names: Optional[Sequence[str]] = None) -&gt; List[RepoFeature]:\n\"\"\"Returns RepoFeatures of surveyed Repos.\n\n        Args:\n            source_names: If specified, only features from the named Sources\n                will be returned.\n            analyzer_names: If specified, only features from the named Analyzers\n                will be returned.\n            feature_names: If specified, only results for the named features\n                will be returned.\n\n        \"\"\"\n        return self.get_db().get_repo_features(source_names=source_names,\n                                               analyzer_names=analyzer_names,\n                                               feature_names=feature_names)\n\n    def get_code_features(self, *,\n                          source_names: Optional[Sequence[str]] = None,\n                          analyzer_names: Optional[Sequence[str]] = None,\n                          feature_names: Optional[Sequence[str]] = None) -&gt; List[CodeFeature]:\n\"\"\"Returns CodeFeatures of surveyed Codes.\n\n        Only returns results from runs where `save_code_results` was `True`.\n\n        Args:\n            source_names: If specified, only features from the named Sources\n                will be returned.\n            analyzer_names: If specified, only features from the named Analyzers\n                will be returned.\n            feature_names: If specified, only results for the named features\n                will be returned.\n\n        \"\"\"\n        return self.get_db().get_code_features(source_names=source_names,\n                                               analyzer_names=analyzer_names,\n                                               feature_names=feature_names)\n\n    def get_survey_tree(self, *,\n                        source_names: Optional[Sequence[str]] = None,\n                        analyzer_names: Optional[Sequence[str]] = None,\n                        feature_names: Optional[Sequence[str]] = None) -&gt; Dict:\n\"\"\"Returns surveyed CodeFeatures and RepoFeatures structured under a\n        tree structure of Sources, Repos, and Analyzers.\n\n        Args:\n            source_names: If specified, only features from the named Sources\n                will be returned.\n            analyzer_names: If specified, only features from the named Analyzers\n                will be returned.\n            feature_names: If specified, only results for the named features\n                will be returned.\n\n        Returns:\n            A dictionary with the following structure:\n                ```python\n                {\n                    'sources': {\n                        '&lt;source_name&gt;': {\n                            'repos: {\n                                '&lt;repo_key&gt;': {\n                                    'analyzers': {\n                                        '&lt;analyzer_name&gt;': {\n                                            'features': {\n                                                'updated': datetime(...),\n                                                'occurence_count': int(...),\n                                                'code_occurrence_count': int(...),\n                                                'code_total_count': int(...),\n                                            },\n                                            # 'codes' key is only present if\n                                            # survey runs are performed with\n                                            # `save_code_features=True`\n                                            'codes': {\n                                                '&lt;code_key&gt;': {\n                                                    'features': {\n                                                        '&lt;feature_name&gt;': {\n                                                            'updated': datetime(...),\n                                                            'occurence_count': int(...),\n                                                        },\n                                                        ...\n                                                    }\n                                                },\n                                                ...\n                                            }\n                                        },\n                                        ...\n                                    },\n                                    'repo_metadata': {\n                                        '&lt;metadata_key&gt;': ...,\n                                        ...\n                                    }\n                                },\n                                ...\n                            }\n                        },\n                        ...\n                    }\n                }\n                ```\n\n        \"\"\"\n        tree: Dict = {'sources': {}}\n        code_features = self.get_code_features(source_names=source_names,\n                                               analyzer_names=analyzer_names,\n                                               feature_names=feature_names)\n        for c in code_features:\n            recursive_update(tree, {\n                'sources': {c.source_name: {\n                    'repos': {c.repo_key: {\n                        'analyzers': {c.analyzer_name: {\n                            'codes': {c.code_key: {\n                                'features': {c.feature_name: {\n                                    'updated': c.updated,\n                                    'occurrence_count': c.occurrence_count,\n                                    'occurrences': c.occurrences,\n                                }}\n                            }}\n                        }},\n                        'repo_metadata': c.repo_metadata,\n                    }}\n                }}\n            })\n        repo_features = self.get_repo_features(source_names=source_names,\n                                               analyzer_names=analyzer_names)\n        for r in repo_features:\n            recursive_update(tree, {\n                'sources': {r.source_name: {\n                    'repos': {r.repo_key: {\n                        'analyzers': {r.analyzer_name: {\n                            'features': {r.feature_name: {\n                                'updated': r.updated,\n                                'occurrence_count': r.occurrence_count,\n                                'code_occurrence_count': r.code_occurrence_count,\n                                'code_total_count': r.code_total_count,\n                            }},\n                        }},\n                        'repo_metadata': r.repo_metadata,\n                    }}\n                }}\n            })\n        return tree\n</code></pre>"},{"location":"core/#codesurvey.CodeSurvey.__init__","title":"<code>__init__(*, sources: Sequence[Source], analyzers: Sequence[Analyzer], db_filepath: str = ':memory:', max_workers: Optional[int] = 1, continue_on_failure: bool = True, save_code_features: bool = True, save_occurrences: bool = True, use_saved_features: bool = True)</code>","text":"<p>Parameters:</p> <ul> <li> sources             (<code>Sequence[Source]</code>)         \u2013          <p>Sources from which to fetch Repos of Codes to survey. If multiple Sources are provided, Repo fetching will cycle through them in a round-robin fashion.</p> </li> <li> analyzers             (<code>Sequence[Analyzer]</code>)         \u2013          <p>Analyzers to identify features in fetched code.</p> </li> <li> db_filepath             (<code>str</code>, default:                 <code>':memory:'</code> )         \u2013          <p>Path to an sqlite database file for persisting survey results. Creates a new sqlite database if the path does not exist. Defaults to a non-persistent in-memory database.</p> </li> <li> max_workers             (<code>Optional[int]</code>, default:                 <code>1</code> )         \u2013          <p>The maximum number of parallel worker processes for fetching Repos from Sources and executing Analyzers. Defaults to a single worker.</p> </li> <li> continue_on_failure             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>If <code>True</code>, exceptions raised by Sources and Analyzers will be logged, but will not halt the survey.</p> </li> <li> save_code_features             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>If <code>True</code>, features of individual Codes will be retained in the survey database. Otherwise, Code features will be deleted once they have been used to compute aggregate features of its respective Repo.</p> </li> <li> save_occurrences             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>If <code>True</code>, occurrence objects returned by FeatureFinders will be saved in the survey database.</p> </li> <li> use_saved_features             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>If <code>True</code>, re-use saved features from an Analyzer for a Code when they already exist in the survey database. Otherwise, reapply all Analyzers to all Codes.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>Invalid survey configuration was specified.</p> </li> </ul> Source code in <code>codesurvey/core.py</code> <pre><code>def __init__(self, *,\n             sources: Sequence[Source],\n             analyzers: Sequence[Analyzer],\n             db_filepath: str = ':memory:',\n             max_workers: Optional[int] = 1,\n             continue_on_failure: bool = True,\n             save_code_features: bool = True,\n             save_occurrences: bool = True,\n             use_saved_features: bool = True):\n\"\"\"\n    Args:\n        sources: Sources from which to fetch Repos of Codes\n            to survey. If multiple Sources are provided, Repo fetching\n            will cycle through them in a round-robin fashion.\n        analyzers: Analyzers to identify features in fetched code.\n        db_filepath: Path to an sqlite database file for persisting survey\n            results. Creates a new sqlite database if the path does not\n            exist. Defaults to a non-persistent in-memory database.\n        max_workers: The maximum number of parallel worker processes for\n            fetching Repos from Sources and executing Analyzers. Defaults\n            to a single worker.\n        continue_on_failure: If `True`, exceptions raised by Sources and\n            Analyzers will be logged, but will not halt the survey.\n        save_code_features: If `True`, features of individual Codes will be\n            retained in the survey database. Otherwise, Code features will\n            be deleted once they have been used to compute aggregate\n            features of its respective Repo.\n        save_occurrences: If `True`, occurrence objects returned by\n            FeatureFinders will be saved in the survey database.\n        use_saved_features: If `True`, re-use saved features from an\n            Analyzer for a Code when they already exist in the survey\n            database. Otherwise, reapply all Analyzers to all Codes.\n\n    Raises:\n        ValueError: Invalid survey configuration was specified.\n\n    \"\"\"\n    duplicate_source_names = get_duplicates([source.name for source in sources])\n    if duplicate_source_names:\n        duplicate_sources_str = ', '.join(duplicate_source_names)\n        raise ValueError(('Cannot instantiate CodeSurvey with duplicate '\n                          f'source names: {duplicate_sources_str}. '\n                          'Please set a unique name for each source.'))\n    self.sources = {source.name: source for source in sources}\n\n    duplicate_analyzer_names = get_duplicates([analyzer.name for analyzer in analyzers])\n    if duplicate_analyzer_names:\n        duplicate_analyzers_str = ', '.join(duplicate_analyzer_names)\n        raise ValueError(('Cannot instantiate CodeSurvey with duplicate '\n                          f'analyzer names: {duplicate_analyzers_str}. '\n                          'Please set a unique name for each analyzer.'))\n    self.analyzers = {analyzer.name: analyzer for analyzer in analyzers}\n\n    self.analyzer_features = {analyzer.name: analyzer.get_feature_names()\n                              for analyzer in analyzers}\n    self.db_filepath = db_filepath\n    self.max_workers = max_workers or os.cpu_count() or 1\n    self.continue_on_failure = continue_on_failure\n    self.save_code_features = save_code_features\n    self.save_occurrences = save_occurrences\n    self.use_saved_features = use_saved_features\n\n    self._runner = CodeSurveyRunner(self)\n</code></pre>"},{"location":"core/#codesurvey.CodeSurvey.run","title":"<code>run(*, max_repos: Optional[int] = None, max_codes: Optional[int] = None, disable_progress: bool = False, progress_analyzer_features: Optional[Mapping[str, Sequence[str]]] = None)</code>","text":"<p>Runs the survey by fetching code from sources and applying analyzers.</p> <p>If neither of the <code>max_repos</code> nor <code>max_codes</code> stopping conditions is specified, the survey will continue running until a <code>KeyboardInterrupt</code> exception.</p> <p>Parameters:</p> <ul> <li> max_repos             (<code>Optional[int]</code>, default:                 <code>None</code> )         \u2013          <p>If specified, the run will stop after analysing this many Repos.</p> </li> <li> max_codes             (<code>Optional[int]</code>, default:                 <code>None</code> )         \u2013          <p>If specified, the run will stop after analysing this many Codes.</p> </li> <li> disable_progress             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If <code>True</code>, do not display tqdm progress bars counting Repos and Codes analyzed.</p> </li> <li> progress_analyzer_features             (<code>Optional[Mapping[str, Sequence[str]]]</code>, default:                 <code>None</code> )         \u2013          <p>Mapping of analyzer names to sequences of feature names for which progress trackers should be displayed to count Repos found with those features. Defaults to all features, but disables feature progress trackers with a warning when there are more than 10 features.</p> </li> </ul> Source code in <code>codesurvey/core.py</code> <pre><code>def run(self, *,\n        max_repos: Optional[int] = None,\n        max_codes: Optional[int] = None,\n        disable_progress: bool = False,\n        progress_analyzer_features: Optional[Mapping[str, Sequence[str]]] = None):\n\"\"\"Runs the survey by fetching code from sources and applying analyzers.\n\n    If neither of the `max_repos` nor `max_codes` stopping\n    conditions is specified, the survey will continue running\n    until a `KeyboardInterrupt` exception.\n\n    Args:\n        max_repos: If specified, the run will stop after analysing this\n            many Repos.\n        max_codes: If specified, the run will stop after analysing this\n            many Codes.\n        disable_progress: If `True`, do not display tqdm progress bars\n            counting Repos and Codes analyzed.\n        progress_analyzer_features: Mapping of analyzer names to sequences\n            of feature names for which progress trackers should be\n            displayed to count Repos found with those features. Defaults\n            to all features, but disables feature progress trackers with\n            a warning when there are more than 10 features.\n\n    \"\"\"\n    self._runner.run(\n        max_repos=max_repos,\n        max_codes=max_codes,\n        disable_progress=disable_progress,\n        progress_analyzer_features=progress_analyzer_features,\n    )\n</code></pre>"},{"location":"core/#codesurvey.CodeSurvey.get_repo_features","title":"<code>get_repo_features(*, source_names: Optional[Sequence[str]] = None, analyzer_names: Optional[Sequence[str]] = None, feature_names: Optional[Sequence[str]] = None) -&gt; List[RepoFeature]</code>","text":"<p>Returns RepoFeatures of surveyed Repos.</p> <p>Parameters:</p> <ul> <li> source_names             (<code>Optional[Sequence[str]]</code>, default:                 <code>None</code> )         \u2013          <p>If specified, only features from the named Sources will be returned.</p> </li> <li> analyzer_names             (<code>Optional[Sequence[str]]</code>, default:                 <code>None</code> )         \u2013          <p>If specified, only features from the named Analyzers will be returned.</p> </li> <li> feature_names             (<code>Optional[Sequence[str]]</code>, default:                 <code>None</code> )         \u2013          <p>If specified, only results for the named features will be returned.</p> </li> </ul> Source code in <code>codesurvey/core.py</code> <pre><code>def get_repo_features(self, *,\n                      source_names: Optional[Sequence[str]] = None,\n                      analyzer_names: Optional[Sequence[str]] = None,\n                      feature_names: Optional[Sequence[str]] = None) -&gt; List[RepoFeature]:\n\"\"\"Returns RepoFeatures of surveyed Repos.\n\n    Args:\n        source_names: If specified, only features from the named Sources\n            will be returned.\n        analyzer_names: If specified, only features from the named Analyzers\n            will be returned.\n        feature_names: If specified, only results for the named features\n            will be returned.\n\n    \"\"\"\n    return self.get_db().get_repo_features(source_names=source_names,\n                                           analyzer_names=analyzer_names,\n                                           feature_names=feature_names)\n</code></pre>"},{"location":"core/#codesurvey.CodeSurvey.get_code_features","title":"<code>get_code_features(*, source_names: Optional[Sequence[str]] = None, analyzer_names: Optional[Sequence[str]] = None, feature_names: Optional[Sequence[str]] = None) -&gt; List[CodeFeature]</code>","text":"<p>Returns CodeFeatures of surveyed Codes.</p> <p>Only returns results from runs where <code>save_code_results</code> was <code>True</code>.</p> <p>Parameters:</p> <ul> <li> source_names             (<code>Optional[Sequence[str]]</code>, default:                 <code>None</code> )         \u2013          <p>If specified, only features from the named Sources will be returned.</p> </li> <li> analyzer_names             (<code>Optional[Sequence[str]]</code>, default:                 <code>None</code> )         \u2013          <p>If specified, only features from the named Analyzers will be returned.</p> </li> <li> feature_names             (<code>Optional[Sequence[str]]</code>, default:                 <code>None</code> )         \u2013          <p>If specified, only results for the named features will be returned.</p> </li> </ul> Source code in <code>codesurvey/core.py</code> <pre><code>def get_code_features(self, *,\n                      source_names: Optional[Sequence[str]] = None,\n                      analyzer_names: Optional[Sequence[str]] = None,\n                      feature_names: Optional[Sequence[str]] = None) -&gt; List[CodeFeature]:\n\"\"\"Returns CodeFeatures of surveyed Codes.\n\n    Only returns results from runs where `save_code_results` was `True`.\n\n    Args:\n        source_names: If specified, only features from the named Sources\n            will be returned.\n        analyzer_names: If specified, only features from the named Analyzers\n            will be returned.\n        feature_names: If specified, only results for the named features\n            will be returned.\n\n    \"\"\"\n    return self.get_db().get_code_features(source_names=source_names,\n                                           analyzer_names=analyzer_names,\n                                           feature_names=feature_names)\n</code></pre>"},{"location":"core/#codesurvey.CodeSurvey.get_survey_tree","title":"<code>get_survey_tree(*, source_names: Optional[Sequence[str]] = None, analyzer_names: Optional[Sequence[str]] = None, feature_names: Optional[Sequence[str]] = None) -&gt; Dict</code>","text":"<p>Returns surveyed CodeFeatures and RepoFeatures structured under a tree structure of Sources, Repos, and Analyzers.</p> <p>Parameters:</p> <ul> <li> source_names             (<code>Optional[Sequence[str]]</code>, default:                 <code>None</code> )         \u2013          <p>If specified, only features from the named Sources will be returned.</p> </li> <li> analyzer_names             (<code>Optional[Sequence[str]]</code>, default:                 <code>None</code> )         \u2013          <p>If specified, only features from the named Analyzers will be returned.</p> </li> <li> feature_names             (<code>Optional[Sequence[str]]</code>, default:                 <code>None</code> )         \u2013          <p>If specified, only results for the named features will be returned.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict</code>         \u2013          <p>A dictionary with the following structure: <pre><code>{\n    'sources': {\n        '&lt;source_name&gt;': {\n            'repos: {\n                '&lt;repo_key&gt;': {\n                    'analyzers': {\n                        '&lt;analyzer_name&gt;': {\n                            'features': {\n                                'updated': datetime(...),\n                                'occurence_count': int(...),\n                                'code_occurrence_count': int(...),\n                                'code_total_count': int(...),\n                            },\n                            # 'codes' key is only present if\n                            # survey runs are performed with\n                            # `save_code_features=True`\n                            'codes': {\n                                '&lt;code_key&gt;': {\n                                    'features': {\n                                        '&lt;feature_name&gt;': {\n                                            'updated': datetime(...),\n                                            'occurence_count': int(...),\n                                        },\n                                        ...\n                                    }\n                                },\n                                ...\n                            }\n                        },\n                        ...\n                    },\n                    'repo_metadata': {\n                        '&lt;metadata_key&gt;': ...,\n                        ...\n                    }\n                },\n                ...\n            }\n        },\n        ...\n    }\n}\n</code></pre></p> </li> </ul> Source code in <code>codesurvey/core.py</code> <pre><code>def get_survey_tree(self, *,\n                    source_names: Optional[Sequence[str]] = None,\n                    analyzer_names: Optional[Sequence[str]] = None,\n                    feature_names: Optional[Sequence[str]] = None) -&gt; Dict:\n\"\"\"Returns surveyed CodeFeatures and RepoFeatures structured under a\n    tree structure of Sources, Repos, and Analyzers.\n\n    Args:\n        source_names: If specified, only features from the named Sources\n            will be returned.\n        analyzer_names: If specified, only features from the named Analyzers\n            will be returned.\n        feature_names: If specified, only results for the named features\n            will be returned.\n\n    Returns:\n        A dictionary with the following structure:\n            ```python\n            {\n                'sources': {\n                    '&lt;source_name&gt;': {\n                        'repos: {\n                            '&lt;repo_key&gt;': {\n                                'analyzers': {\n                                    '&lt;analyzer_name&gt;': {\n                                        'features': {\n                                            'updated': datetime(...),\n                                            'occurence_count': int(...),\n                                            'code_occurrence_count': int(...),\n                                            'code_total_count': int(...),\n                                        },\n                                        # 'codes' key is only present if\n                                        # survey runs are performed with\n                                        # `save_code_features=True`\n                                        'codes': {\n                                            '&lt;code_key&gt;': {\n                                                'features': {\n                                                    '&lt;feature_name&gt;': {\n                                                        'updated': datetime(...),\n                                                        'occurence_count': int(...),\n                                                    },\n                                                    ...\n                                                }\n                                            },\n                                            ...\n                                        }\n                                    },\n                                    ...\n                                },\n                                'repo_metadata': {\n                                    '&lt;metadata_key&gt;': ...,\n                                    ...\n                                }\n                            },\n                            ...\n                        }\n                    },\n                    ...\n                }\n            }\n            ```\n\n    \"\"\"\n    tree: Dict = {'sources': {}}\n    code_features = self.get_code_features(source_names=source_names,\n                                           analyzer_names=analyzer_names,\n                                           feature_names=feature_names)\n    for c in code_features:\n        recursive_update(tree, {\n            'sources': {c.source_name: {\n                'repos': {c.repo_key: {\n                    'analyzers': {c.analyzer_name: {\n                        'codes': {c.code_key: {\n                            'features': {c.feature_name: {\n                                'updated': c.updated,\n                                'occurrence_count': c.occurrence_count,\n                                'occurrences': c.occurrences,\n                            }}\n                        }}\n                    }},\n                    'repo_metadata': c.repo_metadata,\n                }}\n            }}\n        })\n    repo_features = self.get_repo_features(source_names=source_names,\n                                           analyzer_names=analyzer_names)\n    for r in repo_features:\n        recursive_update(tree, {\n            'sources': {r.source_name: {\n                'repos': {r.repo_key: {\n                    'analyzers': {r.analyzer_name: {\n                        'features': {r.feature_name: {\n                            'updated': r.updated,\n                            'occurrence_count': r.occurrence_count,\n                            'code_occurrence_count': r.code_occurrence_count,\n                            'code_total_count': r.code_total_count,\n                        }},\n                    }},\n                    'repo_metadata': r.repo_metadata,\n                }}\n            }}\n        })\n    return tree\n</code></pre>"},{"location":"core/#codesurvey.RepoFeature","title":"<code>codesurvey.RepoFeature</code>  <code>dataclass</code>","text":"Source code in <code>codesurvey/database.py</code> <pre><code>@dataclass(frozen=True)\nclass RepoFeature:\n    updated: datetime\n\"\"\"Timestamp when this analysis was last updated.\"\"\"\n\n    source_name: str\n\"\"\"Name of the Source that produced the target Repo.\"\"\"\n\n    repo_key: str\n\"\"\"Key identifying the target Repo within the Source.\"\"\"\n\n    analyzer_name: str\n\"\"\"Name of the Analyzer that produced this feature.\"\"\"\n\n    feature_name: str\n\"\"\"Name of the analyzed feature.\"\"\"\n\n    occurrence_count: int\n\"\"\"Number of occurrences of this feature within the Repo.\"\"\"\n\n    code_occurrence_count: int\n\"\"\"Number of Codes within the Repo containing this feature.\"\"\"\n\n    code_total_count: int\n\"\"\"Total number of Codes analyzed for this feature within the Repo.\"\"\"\n\n    repo_metadata: Dict[str, Any]\n\"\"\"Metadata of the Repo provided by the Source.\"\"\"\n</code></pre>"},{"location":"core/#codesurvey.RepoFeature.updated","title":"<code>updated: datetime</code>  <code>instance-attribute</code>","text":"<p>Timestamp when this analysis was last updated.</p>"},{"location":"core/#codesurvey.RepoFeature.source_name","title":"<code>source_name: str</code>  <code>instance-attribute</code>","text":"<p>Name of the Source that produced the target Repo.</p>"},{"location":"core/#codesurvey.RepoFeature.repo_key","title":"<code>repo_key: str</code>  <code>instance-attribute</code>","text":"<p>Key identifying the target Repo within the Source.</p>"},{"location":"core/#codesurvey.RepoFeature.analyzer_name","title":"<code>analyzer_name: str</code>  <code>instance-attribute</code>","text":"<p>Name of the Analyzer that produced this feature.</p>"},{"location":"core/#codesurvey.RepoFeature.feature_name","title":"<code>feature_name: str</code>  <code>instance-attribute</code>","text":"<p>Name of the analyzed feature.</p>"},{"location":"core/#codesurvey.RepoFeature.occurrence_count","title":"<code>occurrence_count: int</code>  <code>instance-attribute</code>","text":"<p>Number of occurrences of this feature within the Repo.</p>"},{"location":"core/#codesurvey.RepoFeature.code_occurrence_count","title":"<code>code_occurrence_count: int</code>  <code>instance-attribute</code>","text":"<p>Number of Codes within the Repo containing this feature.</p>"},{"location":"core/#codesurvey.RepoFeature.code_total_count","title":"<code>code_total_count: int</code>  <code>instance-attribute</code>","text":"<p>Total number of Codes analyzed for this feature within the Repo.</p>"},{"location":"core/#codesurvey.RepoFeature.repo_metadata","title":"<code>repo_metadata: Dict[str, Any]</code>  <code>instance-attribute</code>","text":"<p>Metadata of the Repo provided by the Source.</p>"},{"location":"core/#codesurvey.CodeFeature","title":"<code>codesurvey.CodeFeature</code>  <code>dataclass</code>","text":"Source code in <code>codesurvey/database.py</code> <pre><code>@dataclass(frozen=True)\nclass CodeFeature:\n    updated: datetime\n\"\"\"Timestamp when this analysis was last updated.\"\"\"\n\n    source_name: str\n\"\"\"Name of the Source that produced the target Repo.\"\"\"\n\n    repo_key: str\n\"\"\"Key identifying the target Repo within the Source.\"\"\"\n\n    analyzer_name: str\n\"\"\"Name of the Analyzer that produced this feature.\"\"\"\n\n    code_key: str\n\"\"\"Key idenfitying the target Code within the Repo.\"\"\"\n\n    feature_name: str\n\"\"\"Name of the analyzed feature.\"\"\"\n\n    occurrence_count: Optional[int]\n\"\"\"Number of occurrences of this feature within the Code, or `None` if\n    analysis of this Code was skipped.\"\"\"\n\n    occurrences: Optional[List[Dict[str, Any]]]\n\"\"\"Original occurrence objects returned by FeatureFinders.\"\"\"\n\n    repo_metadata: Dict[str, Any]\n\"\"\"Metadata of the Repo provided by the Source.\"\"\"\n</code></pre>"},{"location":"core/#codesurvey.CodeFeature.updated","title":"<code>updated: datetime</code>  <code>instance-attribute</code>","text":"<p>Timestamp when this analysis was last updated.</p>"},{"location":"core/#codesurvey.CodeFeature.source_name","title":"<code>source_name: str</code>  <code>instance-attribute</code>","text":"<p>Name of the Source that produced the target Repo.</p>"},{"location":"core/#codesurvey.CodeFeature.repo_key","title":"<code>repo_key: str</code>  <code>instance-attribute</code>","text":"<p>Key identifying the target Repo within the Source.</p>"},{"location":"core/#codesurvey.CodeFeature.analyzer_name","title":"<code>analyzer_name: str</code>  <code>instance-attribute</code>","text":"<p>Name of the Analyzer that produced this feature.</p>"},{"location":"core/#codesurvey.CodeFeature.code_key","title":"<code>code_key: str</code>  <code>instance-attribute</code>","text":"<p>Key idenfitying the target Code within the Repo.</p>"},{"location":"core/#codesurvey.CodeFeature.feature_name","title":"<code>feature_name: str</code>  <code>instance-attribute</code>","text":"<p>Name of the analyzed feature.</p>"},{"location":"core/#codesurvey.CodeFeature.occurrence_count","title":"<code>occurrence_count: Optional[int]</code>  <code>instance-attribute</code>","text":"<p>Number of occurrences of this feature within the Code, or <code>None</code> if analysis of this Code was skipped.</p>"},{"location":"core/#codesurvey.CodeFeature.occurrences","title":"<code>occurrences: Optional[List[Dict[str, Any]]]</code>  <code>instance-attribute</code>","text":"<p>Original occurrence objects returned by FeatureFinders.</p>"},{"location":"core/#codesurvey.CodeFeature.repo_metadata","title":"<code>repo_metadata: Dict[str, Any]</code>  <code>instance-attribute</code>","text":"<p>Metadata of the Repo provided by the Source.</p>"},{"location":"core/#codesurvey.logger","title":"<code>codesurvey.logger = get_logger()</code>  <code>module-attribute</code>","text":"<p><code>logging.Logger</code> object that codesurvey logs events to during survey runs.</p> <p>Can be used to customize logging:</p> <pre><code>import logging\nfrom codesurvey import logger\n\nlogger.setLevel(logging.ERROR)\n</code></pre>"},{"location":"database/","title":"Results Database","text":"<p>CodeSurvey saves survey results into an sqlite database that can be queried directly, such as by using the sqlite CLI or Python's <code>sqlite3</code> module.</p> <p>The database has the following tables:</p>"},{"location":"database/#repo_metadata","title":"<code>repo_metadata</code>","text":"<p>There is one <code>repo_metadata</code> row for each entry of metadata for each Repo.</p> Column Key Data type Description <code>source_name</code> PK <code>VARCHAR</code> Name of the Source that produced the target Repo <code>repo_key</code> PK <code>VARCHAR</code> Key identifying the target Repo within the Source <code>metadata_key</code> PK <code>VARCHAR</code> Key of this metadata entry <code>metadata_value</code> <code>JSON</code> Value associated with the metadata key <code>updated</code> <code>INTEGER</code> Timestamp when this metadata was last updated"},{"location":"database/#repo_feature","title":"<code>repo_feature</code>","text":"<p>There is one <code>repo_feature</code> row for each Analyzer feature surveyed over all Codes for each Repo.</p> Column Key Data type Description <code>source_name</code> PK <code>VARCHAR</code> Name of the Source that produced the target Repo <code>repo_key</code> PK <code>VARCHAR</code> Key identifying the target Repo within the Source <code>analyzer_name</code> PK <code>VARCHAR</code> Name of the Analyzer that produced this feature <code>feature_name</code> PK <code>VARCHAR</code> Name of the analyzed feature <code>occurrence_count</code> <code>INTEGER</code> Number of occurrences of this feature within the Repo <code>code_occurrence_count</code> <code>INTEGER</code> Number of Codes within the Repo containing this feature <code>code_total_count</code> <code>INTEGER</code> Total number of Codes analyzed for this feature within the Repo <code>updated</code> <code>INTEGER</code> Timestamp when this analysis was last updated"},{"location":"database/#code_feature","title":"<code>code_feature</code>","text":"<p>There is one <code>code_feature</code> row for each Analyzer feature surveyed over each Code from a Repo.</p> Column Key Data type Description <code>source_name</code> PK <code>VARCHAR</code> Name of the Source that produced the target Repo <code>repo_key</code> PK <code>VARCHAR</code> Key identifying the target Repo within the Source <code>analyzer_name</code> PK <code>VARCHAR</code> Name of the Analyzer that produced this feature <code>feature_name</code> PK <code>VARCHAR</code> Name of the analyzed feature <code>code_key</code> PK <code>VARCHAR</code> Key idenfitying the target Code within the Repo <code>occurrence_count</code> <code>INTEGER</code> Number of occurrences of this feature within the Code, or <code>NULL</code> if analysis of this Code was skipped <code>occurrences</code> <code>JSON</code> Original occurrence objects returned by FeatureFinders, or <code>NULL</code> if analysis of this Code was skipped or <code>save_occurrences</code> was not enabled on the CodeSurvey <code>updated</code> <code>INTEGER</code> Timestamp when this analysis was last updated"},{"location":"analyzers/core/","title":"Core Analyzers","text":"<p>The purpose of an <code>Analyzer</code> is to find units of source-code (typically source-code files) within a <code>Repo</code> provided by a <code>Source</code>. An <code>Analyzer</code> is configured with one or more <code>FeatureFinders</code> for identifying occurrences of features of interest within a unit of source-code.</p> <p>This document provides details of the core <code>Analyzer</code> classes that can be used to define custom <code>Analyzer</code> types, while usage of built-in language-specific Analyzers is documented in the following sub-pages:</p> <ul> <li>Python</li> </ul>"},{"location":"analyzers/core/#custom-file-analyzers","title":"Custom File Analyzers","text":"<p>You can define your own Analyzer to analyze languages not supported by the built-in Analyzers, or to use different approaches to parse or interpret source-code.</p> <p>Most Analyzers will treat each source-code file within a Repo as the unit of source-code. Such Analyzers should inherit from <code>FileAnalyzer</code> and implement a <code>prepare_file()</code> method that receives a <code>FileInfo</code> and returns an appropriate code representation. The code representation could be a simple string of source-code, or a parsed structure like an abstract syntax tree (AST) - the type should be specified as a type argument when inheriting from <code>FileAnalyzer</code> (e.g. <code>class CustomAnalyzer(FileAnalyzer[str])</code>).</p> <p>Your Analyzer should specify a <code>default_file_glob</code> attribute to find source-code files of interest, and may define a set of <code>default_file_filters</code> to exclude certain files.</p> <p>Your Analyzer should also specify a <code>default_name</code> class attribute that will be used to identify your Analyzer in logs and results (except where a name is provided for a specific Analyzer instance).</p> <p>For example, to define a custom Analyzer that receives a <code>custom_arg</code>, looks for <code>.py</code> files, excludes filenames beginning with an underscore, and represents source-code files for FeatureFinders as strings:</p> <pre><code>def leading_underscore_file_filter(file_info):\n    return os.path.basename(file_info.rel_path).startswith('_')\n\nclass CustomAnalyzer(FileAnalyzer[str]):\n    default_name = 'custom'\n    default_file_glob = '**/*.py'\n    default_file_filters = [\n        leading_underscore_file_filter,\n    ]\n\n    def __init__(self, custom_arg, *,\n                 feature_finders: Sequence[FeatureFinder], *,\n                 file_glob: Optional[str] = None,\n                 file_filters: Optional[Sequence[Callable[[FileInfo], bool]]] = None,\n                 name: Optional[str] = None):\n        self.custom_arg = custom_arg\n        super().__init__(\n            feature_finders=feature_finders,\n            file_glob=file_glob,\n            file_filters=file_filters,\n            name=name,\n        )\n\n    def prepare_file(self, file_info: FileInfo) -&gt; str:\n        with open(file_info.abs_path) as code_file:\n            return code_file.read()\n</code></pre> <p>When defining a custom Analyzer, you will also need to implement custom FeatureFinders that expect to receive the type of code representation you specify for your Analyzer.</p>"},{"location":"analyzers/core/#file-analyzer-classes","title":"File Analyzer Classes","text":""},{"location":"analyzers/core/#codesurvey.analyzers.FileAnalyzer","title":"<code>codesurvey.analyzers.FileAnalyzer</code>","text":"<p>             Bases: <code>Analyzer[CodeReprT]</code></p> <p>Base class for Analyzers that analyze each source-code file as the target unit of code within a Repo.</p> <p>The type argument is the representation of source-code units that will be provided to FeatureFinders used with Analyzer instances.</p> Source code in <code>codesurvey/analyzers/core.py</code> <pre><code>class FileAnalyzer(Analyzer[CodeReprT]):\n\"\"\"Base class for Analyzers that analyze each source-code file as the\n    target unit of code within a Repo.\n\n    The type argument is the representation of source-code units that\n    will be provided to FeatureFinders used with Analyzer instances.\n\n    \"\"\"\n\n    default_file_glob: str\n\"\"\"Default glob pattern for finding source-code files. To be assigned\n    to FileAnalyzers of this type if a custom glob is not specified.\"\"\"\n\n    default_file_filters: Sequence[Callable[[FileInfo], bool]] = []\n\"\"\"Default filters to identify files to exclude from analysis. To be\n    assigned to FileAnalyzers of this type if custom filters are not\n    specified.\"\"\"\n\n    def __init__(self, feature_finders: Sequence[FeatureFinder], *,\n                 file_glob: Optional[str] = None,\n                 file_filters: Optional[Sequence[Callable[[FileInfo], bool]]] = None,\n                 name: Optional[str] = None):\n\"\"\"\n        Args:\n            feature_finders:\n                The [FeatureFinders][codesurvey.analyzers.FeatureFinder]\n                for analyzing each source-code file.\n            file_glob: Glob pattern for finding source-code files within\n                the Repo.\n            file_filters: Filters to identify files to exclude from analysis.\n                Each filter is a function that takes a\n                [`FileInfo`][codesurvey.analyzers.FileInfo] and\n                returns `True` if the file should be excluded. file_filters\n                cannot be lambdas, as they need to be pickled when passed to\n                sub-processes.\n            name: Name to identify the Analyzer. If `None`, defaults to the\n                Analyzer type's default_name.\n\n        \"\"\"\n        super().__init__(feature_finders=feature_finders, name=name)\n        self.file_glob = self.default_file_glob if file_glob is None else file_glob\n        self.file_filters = self.default_file_filters if file_filters is None else file_filters\n\n    @abstractmethod\n    def prepare_file(self, file_info: FileInfo) -&gt; CodeReprT:\n\"\"\"Given a [`FileInfo`][codesurvey.analyzers.FileInfo] identifying the\n        location of a target source-code file, returns a\n        representation of the code that can be passed to the\n        [FeatureFinders][codesurvey.analyzers.FeatureFinder] of this\n        Analyzer.\"\"\"\n\n    def prepare_code_representation(self, repo: Repo, code_key: str) -&gt; CodeReprT:\n        file_info = FileInfo(repo=repo, rel_path=code_key)\n        return self.prepare_file(file_info)\n\n    def _get_file_keys(self, repo: Repo) -&gt; Iterator[str]:\n\"\"\"Generator yielding the code_keys (relative file paths) within the\n        given Repo, applying configured file_filters.\"\"\"\n        for abs_path in iglob(os.path.join(repo.path, self.file_glob), recursive=True):\n            if not os.path.isfile(abs_path):\n                continue\n            file_info = FileInfo(\n                repo=repo,\n                rel_path=os.path.relpath(abs_path, start=repo.path),\n            )\n            filtered_out = any([\n                file_filter(file_info)\n                for file_filter in self.file_filters\n            ])\n            if filtered_out:\n                continue\n            yield file_info.rel_path\n\n    def code_generator(self, repo: Repo, *,\n                       get_code_features: Callable[[str], Sequence[str]]) -&gt; Iterator[CodeThunk]:\n        for file_key in self._get_file_keys(repo):\n            features = get_code_features(file_key)\n            if len(features) == 0:\n                continue\n\n            yield self.code_thunk(\n                repo=repo,\n                key=file_key,\n                features=features,\n                thunk=partial(self.analyze_code, repo=repo, code_key=file_key, features=features),\n            )\n\n    def test(self, code_snippet: str, *, test_filename: str = 'test_file.txt') -&gt; Dict[str, Feature]:\n\"\"\"Utility for directly analyzing a string of source-code.\n\n        A Repo will be created in a temporary directory to perform\n        analysis of a file created with the given `code_snippet`.\n\n        Args:\n            code_snippet: String of source-code to analyze.\n            test_filename: Optional custom filename used for the test file.\n\n        Returns:\n            A dictionary mapping feature names to\n                [`Feature`][codesurvey.analyzers.Feature] results.\n\n        \"\"\"\n        source = TestSource({test_filename: code_snippet})\n        repo = next(source.repo_generator())\n        code = self.analyze_code(\n            repo=repo,\n            code_key=test_filename,\n            features=self.get_feature_names(),\n        )\n        return code.features\n</code></pre>"},{"location":"analyzers/core/#codesurvey.analyzers.FileAnalyzer.default_file_glob","title":"<code>default_file_glob: str</code>  <code>instance-attribute</code>","text":"<p>Default glob pattern for finding source-code files. To be assigned to FileAnalyzers of this type if a custom glob is not specified.</p>"},{"location":"analyzers/core/#codesurvey.analyzers.FileAnalyzer.default_file_filters","title":"<code>default_file_filters: Sequence[Callable[[FileInfo], bool]] = []</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Default filters to identify files to exclude from analysis. To be assigned to FileAnalyzers of this type if custom filters are not specified.</p>"},{"location":"analyzers/core/#codesurvey.analyzers.FileAnalyzer.__init__","title":"<code>__init__(feature_finders: Sequence[FeatureFinder], *, file_glob: Optional[str] = None, file_filters: Optional[Sequence[Callable[[FileInfo], bool]]] = None, name: Optional[str] = None)</code>","text":"<p>Parameters:</p> <ul> <li> feature_finders             (<code>Sequence[FeatureFinder]</code>)         \u2013          <p>The FeatureFinders for analyzing each source-code file.</p> </li> <li> file_glob             (<code>Optional[str]</code>, default:                 <code>None</code> )         \u2013          <p>Glob pattern for finding source-code files within the Repo.</p> </li> <li> file_filters             (<code>Optional[Sequence[Callable[[FileInfo], bool]]]</code>, default:                 <code>None</code> )         \u2013          <p>Filters to identify files to exclude from analysis. Each filter is a function that takes a <code>FileInfo</code> and returns <code>True</code> if the file should be excluded. file_filters cannot be lambdas, as they need to be pickled when passed to sub-processes.</p> </li> <li> name             (<code>Optional[str]</code>, default:                 <code>None</code> )         \u2013          <p>Name to identify the Analyzer. If <code>None</code>, defaults to the Analyzer type's default_name.</p> </li> </ul> Source code in <code>codesurvey/analyzers/core.py</code> <pre><code>def __init__(self, feature_finders: Sequence[FeatureFinder], *,\n             file_glob: Optional[str] = None,\n             file_filters: Optional[Sequence[Callable[[FileInfo], bool]]] = None,\n             name: Optional[str] = None):\n\"\"\"\n    Args:\n        feature_finders:\n            The [FeatureFinders][codesurvey.analyzers.FeatureFinder]\n            for analyzing each source-code file.\n        file_glob: Glob pattern for finding source-code files within\n            the Repo.\n        file_filters: Filters to identify files to exclude from analysis.\n            Each filter is a function that takes a\n            [`FileInfo`][codesurvey.analyzers.FileInfo] and\n            returns `True` if the file should be excluded. file_filters\n            cannot be lambdas, as they need to be pickled when passed to\n            sub-processes.\n        name: Name to identify the Analyzer. If `None`, defaults to the\n            Analyzer type's default_name.\n\n    \"\"\"\n    super().__init__(feature_finders=feature_finders, name=name)\n    self.file_glob = self.default_file_glob if file_glob is None else file_glob\n    self.file_filters = self.default_file_filters if file_filters is None else file_filters\n</code></pre>"},{"location":"analyzers/core/#codesurvey.analyzers.FileAnalyzer.prepare_file","title":"<code>prepare_file(file_info: FileInfo) -&gt; CodeReprT</code>  <code>abstractmethod</code>","text":"<p>Given a <code>FileInfo</code> identifying the location of a target source-code file, returns a representation of the code that can be passed to the FeatureFinders of this Analyzer.</p> Source code in <code>codesurvey/analyzers/core.py</code> <pre><code>@abstractmethod\ndef prepare_file(self, file_info: FileInfo) -&gt; CodeReprT:\n\"\"\"Given a [`FileInfo`][codesurvey.analyzers.FileInfo] identifying the\n    location of a target source-code file, returns a\n    representation of the code that can be passed to the\n    [FeatureFinders][codesurvey.analyzers.FeatureFinder] of this\n    Analyzer.\"\"\"\n</code></pre>"},{"location":"analyzers/core/#codesurvey.analyzers.FileAnalyzer.test","title":"<code>test(code_snippet: str, *, test_filename: str = 'test_file.txt') -&gt; Dict[str, Feature]</code>","text":"<p>Utility for directly analyzing a string of source-code.</p> <p>A Repo will be created in a temporary directory to perform analysis of a file created with the given <code>code_snippet</code>.</p> <p>Parameters:</p> <ul> <li> code_snippet             (<code>str</code>)         \u2013          <p>String of source-code to analyze.</p> </li> <li> test_filename             (<code>str</code>, default:                 <code>'test_file.txt'</code> )         \u2013          <p>Optional custom filename used for the test file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict[str, Feature]</code>         \u2013          <p>A dictionary mapping feature names to <code>Feature</code> results.</p> </li> </ul> Source code in <code>codesurvey/analyzers/core.py</code> <pre><code>def test(self, code_snippet: str, *, test_filename: str = 'test_file.txt') -&gt; Dict[str, Feature]:\n\"\"\"Utility for directly analyzing a string of source-code.\n\n    A Repo will be created in a temporary directory to perform\n    analysis of a file created with the given `code_snippet`.\n\n    Args:\n        code_snippet: String of source-code to analyze.\n        test_filename: Optional custom filename used for the test file.\n\n    Returns:\n        A dictionary mapping feature names to\n            [`Feature`][codesurvey.analyzers.Feature] results.\n\n    \"\"\"\n    source = TestSource({test_filename: code_snippet})\n    repo = next(source.repo_generator())\n    code = self.analyze_code(\n        repo=repo,\n        code_key=test_filename,\n        features=self.get_feature_names(),\n    )\n    return code.features\n</code></pre>"},{"location":"analyzers/core/#codesurvey.analyzers.FileInfo","title":"<code>codesurvey.analyzers.FileInfo</code>  <code>dataclass</code>","text":"<p>Details identifying a source-code file within a Repo.</p> Source code in <code>codesurvey/analyzers/core.py</code> <pre><code>@dataclass(frozen=True)\nclass FileInfo:\n\"\"\"Details identifying a source-code file within a Repo.\"\"\"\n\n    repo: Repo\n\"\"\"Repo that the file belongs to.\"\"\"\n\n    rel_path: str\n\"\"\"Relative path to the file from the Repo directory.\"\"\"\n\n    @property\n    def abs_path(self) -&gt; str:\n\"\"\"Absolute path to the file.\"\"\"\n        return os.path.join(self.repo.path, self.rel_path)\n</code></pre>"},{"location":"analyzers/core/#codesurvey.analyzers.FileInfo.repo","title":"<code>repo: Repo</code>  <code>instance-attribute</code>","text":"<p>Repo that the file belongs to.</p>"},{"location":"analyzers/core/#codesurvey.analyzers.FileInfo.rel_path","title":"<code>rel_path: str</code>  <code>instance-attribute</code>","text":"<p>Relative path to the file from the Repo directory.</p>"},{"location":"analyzers/core/#codesurvey.analyzers.FileInfo.abs_path","title":"<code>abs_path: str</code>  <code>property</code>","text":"<p>Absolute path to the file.</p>"},{"location":"analyzers/core/#other-custom-analyzers","title":"Other Custom Analyzers","text":"<p>For Analyzers that don't treat each file as a unit of source-code, you can define an Analyzer that inherits from <code>Analyzer</code> and defines <code>prepare_code_representation()</code> and <code>code_generator()</code>. <code>prepare_code_representation()</code> returns a representation (such as a simple string, or a parsed structure like an abstract syntax tree) for a specific unit of source-code, while <code>code_generator()</code> returns Code results of analyzing each unit of source-code, or CodeThunks that can be executed in a parallelizable sub-process in order to analyze a unit of source-code.</p>"},{"location":"analyzers/core/#core-classes","title":"Core Classes","text":""},{"location":"analyzers/core/#codesurvey.analyzers.Analyzer","title":"<code>codesurvey.analyzers.Analyzer</code>","text":"<p>             Bases: <code>ABC</code>, <code>Generic[CodeReprT]</code></p> <p>Analyzes Repos to produce Code feature analysis results of individual units of source-code (such as source-code files).</p> <p>The type argument is the representation of source-code units that will be provided to FeatureFinders used with Analyzer instances.</p> Source code in <code>codesurvey/analyzers/core.py</code> <pre><code>class Analyzer(ABC, Generic[CodeReprT]):\n\"\"\"Analyzes Repos to produce Code feature analysis results of\n    individual units of source-code (such as source-code files).\n\n    The type argument is the representation of source-code units that\n    will be provided to FeatureFinders used with Analyzer instances.\n\n    \"\"\"\n\n    default_name: str\n\"\"\"Name to be assigned to Analyzers of this type if a custom name is not\n    specified.\"\"\"\n\n    def __init__(self, *, feature_finders: Sequence[FeatureFinder[CodeReprT]],\n                 name: Optional[str] = None):\n\"\"\"\n        Args:\n            feature_finders:\n                The [FeatureFinders][codesurvey.analyzers.FeatureFinder]\n                for analyzing each source-code unit.\n            name: Name to identify the Analyzer. If `None`, defaults to the\n                Analyzer type's default_name\n        \"\"\"\n        self.name = self.default_name if name is None else name\n        duplicate_feature_names = get_duplicates([feature.name for feature in feature_finders])\n        if duplicate_feature_names:\n            duplicate_features_str = ', '.join(duplicate_feature_names)\n            raise ValueError((f'Cannot instantiate analyzer \"{self}\" with duplicate '\n                              f'feature names: {duplicate_features_str}. '\n                              'Please set a unique name for each feature_finder.'))\n        self.feature_finders = {feature.name: feature for feature in feature_finders}\n\n    @abstractmethod\n    def prepare_code_representation(self, repo: Repo, code_key: str) -&gt; CodeReprT:\n\"\"\"Returns a representation of a source-code unit that can be passed\n        to the [FeatureFinders][codesurvey.analyzers.FeatureFinder] of\n        this Analyzer.\n\n        Args:\n            repo: Repo containing the source-code to be analyzed.\n            code_key: Unique key of the source-code unit to be analyzed\n                within the Repo.\n\n        \"\"\"\n\n    @abstractmethod\n    def code_generator(self, repo: Repo, *,\n                       get_code_features: Callable[[str], Sequence[str]]) -&gt; Iterator[Union[Code, CodeThunk]]:\n\"\"\"Generator yielding [Codes][codesurvey.analyzers.Code] analysis\n        results of source-code units within the given Repo, or\n        [CodeThunks][codesurvey.analyzers.CodeThunk] that can be\n        executed to perform such analyses.\n\n        Args:\n            repo: Repo containing the source-code to be analyzed.\n            get_code_features: A function that will be called by\n                `code_generator()` with a Code's key to get the subset of\n                [`get_feature_names()`][codesurvey.analyzers.Analyzer.get_feature_names]\n                that should be analyzed for that Code.\n\n        \"\"\"\n\n    def __str__(self):\n        return self.name\n\n    def __repr__(self):\n        return f'{self.__class__.__name__}({self})'\n\n    def analyze_code(self, repo: Repo, code_key: str, features: Sequence[str]) -&gt; Code:\n\"\"\"Produces a [Code][codesurvey.analyzers.Code] analysis for a single\n        unit of source-code within a Repo.\n\n        Args:\n            repo: Repo containing the source-code to be analyzed.\n            code_key: Unique key of the source-code unit to be analyzed\n                within the Repo.\n            features: Names of features to include in the analysis.\n                A subset of the names returned by\n                [`get_feature_names()`][codesurvey.analyzers.Analyzer.get_feature_names].\n\n        \"\"\"\n        code_repr = self.prepare_code_representation(repo=repo, code_key=code_key)\n        if code_repr is None:\n            feature_results = {feature_name: Feature(name=feature_name, ignore=True)\n                               for feature_name in features}\n        else:\n            feature_results = {feature_name: self.feature_finders[feature_name](code_repr)\n                               for feature_name in features}\n        return self.code(\n            repo=repo,\n            key=code_key,\n            features=feature_results,\n        )\n\n    def get_feature_names(self) -&gt; Sequence[str]:\n\"\"\"Returns the names of all features analyzed by this Analyzer instance.\"\"\"\n        return list(self.feature_finders.keys())\n\n    def code(self, **kwargs) -&gt; Code:\n\"\"\"Internal helper to generate a Code for this Analyzer. Takes the same\n        arguments as Code except for analyzer.\"\"\"\n        return Code(analyzer=self, **kwargs)\n\n    def code_thunk(self, **kwargs) -&gt; CodeThunk:\n\"\"\"Internal helper to generate a CodeThunk for this Analyzer. Takes\n        the same arguments as CodeThunk except for analyzer.\"\"\"\n        return CodeThunk(analyzer=self, **kwargs)\n</code></pre>"},{"location":"analyzers/core/#codesurvey.analyzers.Analyzer.default_name","title":"<code>default_name: str</code>  <code>instance-attribute</code>","text":"<p>Name to be assigned to Analyzers of this type if a custom name is not specified.</p>"},{"location":"analyzers/core/#codesurvey.analyzers.Analyzer.__init__","title":"<code>__init__(*, feature_finders: Sequence[FeatureFinder[CodeReprT]], name: Optional[str] = None)</code>","text":"<p>Parameters:</p> <ul> <li> feature_finders             (<code>Sequence[FeatureFinder[CodeReprT]]</code>)         \u2013          <p>The FeatureFinders for analyzing each source-code unit.</p> </li> <li> name             (<code>Optional[str]</code>, default:                 <code>None</code> )         \u2013          <p>Name to identify the Analyzer. If <code>None</code>, defaults to the Analyzer type's default_name</p> </li> </ul> Source code in <code>codesurvey/analyzers/core.py</code> <pre><code>def __init__(self, *, feature_finders: Sequence[FeatureFinder[CodeReprT]],\n             name: Optional[str] = None):\n\"\"\"\n    Args:\n        feature_finders:\n            The [FeatureFinders][codesurvey.analyzers.FeatureFinder]\n            for analyzing each source-code unit.\n        name: Name to identify the Analyzer. If `None`, defaults to the\n            Analyzer type's default_name\n    \"\"\"\n    self.name = self.default_name if name is None else name\n    duplicate_feature_names = get_duplicates([feature.name for feature in feature_finders])\n    if duplicate_feature_names:\n        duplicate_features_str = ', '.join(duplicate_feature_names)\n        raise ValueError((f'Cannot instantiate analyzer \"{self}\" with duplicate '\n                          f'feature names: {duplicate_features_str}. '\n                          'Please set a unique name for each feature_finder.'))\n    self.feature_finders = {feature.name: feature for feature in feature_finders}\n</code></pre>"},{"location":"analyzers/core/#codesurvey.analyzers.Analyzer.prepare_code_representation","title":"<code>prepare_code_representation(repo: Repo, code_key: str) -&gt; CodeReprT</code>  <code>abstractmethod</code>","text":"<p>Returns a representation of a source-code unit that can be passed to the FeatureFinders of this Analyzer.</p> <p>Parameters:</p> <ul> <li> repo             (<code>Repo</code>)         \u2013          <p>Repo containing the source-code to be analyzed.</p> </li> <li> code_key             (<code>str</code>)         \u2013          <p>Unique key of the source-code unit to be analyzed within the Repo.</p> </li> </ul> Source code in <code>codesurvey/analyzers/core.py</code> <pre><code>@abstractmethod\ndef prepare_code_representation(self, repo: Repo, code_key: str) -&gt; CodeReprT:\n\"\"\"Returns a representation of a source-code unit that can be passed\n    to the [FeatureFinders][codesurvey.analyzers.FeatureFinder] of\n    this Analyzer.\n\n    Args:\n        repo: Repo containing the source-code to be analyzed.\n        code_key: Unique key of the source-code unit to be analyzed\n            within the Repo.\n\n    \"\"\"\n</code></pre>"},{"location":"analyzers/core/#codesurvey.analyzers.Analyzer.code_generator","title":"<code>code_generator(repo: Repo, *, get_code_features: Callable[[str], Sequence[str]]) -&gt; Iterator[Union[Code, CodeThunk]]</code>  <code>abstractmethod</code>","text":"<p>Generator yielding Codes analysis results of source-code units within the given Repo, or CodeThunks that can be executed to perform such analyses.</p> <p>Parameters:</p> <ul> <li> repo             (<code>Repo</code>)         \u2013          <p>Repo containing the source-code to be analyzed.</p> </li> <li> get_code_features             (<code>Callable[[str], Sequence[str]]</code>)         \u2013          <p>A function that will be called by <code>code_generator()</code> with a Code's key to get the subset of <code>get_feature_names()</code> that should be analyzed for that Code.</p> </li> </ul> Source code in <code>codesurvey/analyzers/core.py</code> <pre><code>@abstractmethod\ndef code_generator(self, repo: Repo, *,\n                   get_code_features: Callable[[str], Sequence[str]]) -&gt; Iterator[Union[Code, CodeThunk]]:\n\"\"\"Generator yielding [Codes][codesurvey.analyzers.Code] analysis\n    results of source-code units within the given Repo, or\n    [CodeThunks][codesurvey.analyzers.CodeThunk] that can be\n    executed to perform such analyses.\n\n    Args:\n        repo: Repo containing the source-code to be analyzed.\n        get_code_features: A function that will be called by\n            `code_generator()` with a Code's key to get the subset of\n            [`get_feature_names()`][codesurvey.analyzers.Analyzer.get_feature_names]\n            that should be analyzed for that Code.\n\n    \"\"\"\n</code></pre>"},{"location":"analyzers/core/#codesurvey.analyzers.Analyzer.analyze_code","title":"<code>analyze_code(repo: Repo, code_key: str, features: Sequence[str]) -&gt; Code</code>","text":"<p>Produces a Code analysis for a single unit of source-code within a Repo.</p> <p>Parameters:</p> <ul> <li> repo             (<code>Repo</code>)         \u2013          <p>Repo containing the source-code to be analyzed.</p> </li> <li> code_key             (<code>str</code>)         \u2013          <p>Unique key of the source-code unit to be analyzed within the Repo.</p> </li> <li> features             (<code>Sequence[str]</code>)         \u2013          <p>Names of features to include in the analysis. A subset of the names returned by <code>get_feature_names()</code>.</p> </li> </ul> Source code in <code>codesurvey/analyzers/core.py</code> <pre><code>def analyze_code(self, repo: Repo, code_key: str, features: Sequence[str]) -&gt; Code:\n\"\"\"Produces a [Code][codesurvey.analyzers.Code] analysis for a single\n    unit of source-code within a Repo.\n\n    Args:\n        repo: Repo containing the source-code to be analyzed.\n        code_key: Unique key of the source-code unit to be analyzed\n            within the Repo.\n        features: Names of features to include in the analysis.\n            A subset of the names returned by\n            [`get_feature_names()`][codesurvey.analyzers.Analyzer.get_feature_names].\n\n    \"\"\"\n    code_repr = self.prepare_code_representation(repo=repo, code_key=code_key)\n    if code_repr is None:\n        feature_results = {feature_name: Feature(name=feature_name, ignore=True)\n                           for feature_name in features}\n    else:\n        feature_results = {feature_name: self.feature_finders[feature_name](code_repr)\n                           for feature_name in features}\n    return self.code(\n        repo=repo,\n        key=code_key,\n        features=feature_results,\n    )\n</code></pre>"},{"location":"analyzers/core/#codesurvey.analyzers.Analyzer.get_feature_names","title":"<code>get_feature_names() -&gt; Sequence[str]</code>","text":"<p>Returns the names of all features analyzed by this Analyzer instance.</p> Source code in <code>codesurvey/analyzers/core.py</code> <pre><code>def get_feature_names(self) -&gt; Sequence[str]:\n\"\"\"Returns the names of all features analyzed by this Analyzer instance.\"\"\"\n    return list(self.feature_finders.keys())\n</code></pre>"},{"location":"analyzers/core/#codesurvey.analyzers.Analyzer.code","title":"<code>code(**kwargs) -&gt; Code</code>","text":"<p>Internal helper to generate a Code for this Analyzer. Takes the same arguments as Code except for analyzer.</p> Source code in <code>codesurvey/analyzers/core.py</code> <pre><code>def code(self, **kwargs) -&gt; Code:\n\"\"\"Internal helper to generate a Code for this Analyzer. Takes the same\n    arguments as Code except for analyzer.\"\"\"\n    return Code(analyzer=self, **kwargs)\n</code></pre>"},{"location":"analyzers/core/#codesurvey.analyzers.Analyzer.code_thunk","title":"<code>code_thunk(**kwargs) -&gt; CodeThunk</code>","text":"<p>Internal helper to generate a CodeThunk for this Analyzer. Takes the same arguments as CodeThunk except for analyzer.</p> Source code in <code>codesurvey/analyzers/core.py</code> <pre><code>def code_thunk(self, **kwargs) -&gt; CodeThunk:\n\"\"\"Internal helper to generate a CodeThunk for this Analyzer. Takes\n    the same arguments as CodeThunk except for analyzer.\"\"\"\n    return CodeThunk(analyzer=self, **kwargs)\n</code></pre>"},{"location":"analyzers/core/#codesurvey.analyzers.Code","title":"<code>codesurvey.analyzers.Code</code>  <code>dataclass</code>","text":"<p>Results of analyzing a single unit of source-code from a Repo (e.g. a file of source-code) for occurrences of target features.</p> Source code in <code>codesurvey/analyzers/core.py</code> <pre><code>@dataclass(frozen=True)\nclass Code:\n\"\"\"Results of analyzing a single unit of source-code from a Repo (e.g.\n    a file of source-code) for occurrences of target features.\"\"\"\n\n    analyzer: 'Analyzer'\n\"\"\"The Analyzer that performed the analysis.\"\"\"\n\n    repo: Repo\n\"\"\"The Repo that the Code belongs to.\"\"\"\n\n    key: str\n\"\"\"The unique key of the Code within its Repo.\"\"\"\n\n    features: Dict[str, Feature]\n\"\"\"A mapping of feature names to Feature survey results.\"\"\"\n</code></pre>"},{"location":"analyzers/core/#codesurvey.analyzers.Code.analyzer","title":"<code>analyzer: Analyzer</code>  <code>instance-attribute</code>","text":"<p>The Analyzer that performed the analysis.</p>"},{"location":"analyzers/core/#codesurvey.analyzers.Code.repo","title":"<code>repo: Repo</code>  <code>instance-attribute</code>","text":"<p>The Repo that the Code belongs to.</p>"},{"location":"analyzers/core/#codesurvey.analyzers.Code.key","title":"<code>key: str</code>  <code>instance-attribute</code>","text":"<p>The unique key of the Code within its Repo.</p>"},{"location":"analyzers/core/#codesurvey.analyzers.Code.features","title":"<code>features: Dict[str, Feature]</code>  <code>instance-attribute</code>","text":"<p>A mapping of feature names to Feature survey results.</p>"},{"location":"analyzers/core/#codesurvey.analyzers.CodeThunk","title":"<code>codesurvey.analyzers.CodeThunk</code>  <code>dataclass</code>","text":"<p>An executable task to be run asynchronously to produce a Code analysis.</p> Source code in <code>codesurvey/analyzers/core.py</code> <pre><code>@dataclass(frozen=True)\nclass CodeThunk:\n\"\"\"An executable task to be run asynchronously to produce a Code\n    analysis.\"\"\"\n\n    analyzer: 'Analyzer'\n\"\"\"The Analyzer that will perform the analysis.\"\"\"\n\n    repo: Repo\n\"\"\"The Repo that the Code belongs to.\"\"\"\n\n    key: str\n\"\"\"The unique key of the Code within its Repo.\"\"\"\n\n    features: Sequence[str]\n\"\"\"The names of features to be analyzed.\"\"\"\n\n    thunk: Callable[[], Code]\n\"\"\"Function to be called to perform the analysis.\"\"\"\n</code></pre>"},{"location":"analyzers/core/#codesurvey.analyzers.CodeThunk.analyzer","title":"<code>analyzer: Analyzer</code>  <code>instance-attribute</code>","text":"<p>The Analyzer that will perform the analysis.</p>"},{"location":"analyzers/core/#codesurvey.analyzers.CodeThunk.repo","title":"<code>repo: Repo</code>  <code>instance-attribute</code>","text":"<p>The Repo that the Code belongs to.</p>"},{"location":"analyzers/core/#codesurvey.analyzers.CodeThunk.key","title":"<code>key: str</code>  <code>instance-attribute</code>","text":"<p>The unique key of the Code within its Repo.</p>"},{"location":"analyzers/core/#codesurvey.analyzers.CodeThunk.features","title":"<code>features: Sequence[str]</code>  <code>instance-attribute</code>","text":"<p>The names of features to be analyzed.</p>"},{"location":"analyzers/core/#codesurvey.analyzers.CodeThunk.thunk","title":"<code>thunk: Callable[[], Code]</code>  <code>instance-attribute</code>","text":"<p>Function to be called to perform the analysis.</p>"},{"location":"analyzers/features/","title":"Feature Finders","text":"<p>Each <code>Analyzer</code> is configured with a set of FeatureFinders that identify occurrences of features of interest within a unit of source-code.</p> <p>A <code>FeatureFinder</code> can be any function with a <code>name</code> attribute that receives an object representing a unit of source-code (the type of the object will depend on the <code>Analyzer</code> being used) and returns a <code>Feature</code>.</p>"},{"location":"analyzers/features/#defining-feature-finders","title":"Defining Feature Finders","text":"<p>The following utility functions can be used to define your own <code>FeatureFinders</code>.</p> <p>For convenience, feature finding functions wrapped with these utilities you can return a dictionary with one of the following structures instead of a <code>Feature</code> object:</p> <pre><code># A feature finder should typically return a list of occurrences of the\n# feature in the given code_representation. Each occurrence should be a\n# JSON-serializable dictionary that can capture whatever keys make sense\n# for your feature.\n{\n    'occurrences': List[dict]\n}\n# Return an 'ignore' result in cases where the\n# code_representation cannot be analyzed.\n{\n    'ignore': bool\n}\n</code></pre>"},{"location":"analyzers/features/#codesurvey.analyzers.feature_finder","title":"<code>codesurvey.analyzers.feature_finder(name)</code>","text":"<p>Decorator for defining a named <code>FeatureFinder</code>.</p> <p>Example usage:</p> <pre><code>@feature_finder('while')\ndef has_while(code_representation):\n    if code_representation is None:\n        return {'ignore': True}\n    return {\n        'occurrences': [\n            {'character_index': match.start()}\n            for match in re.finditer('test', str(code_representation))\n        ]\n    }\n</code></pre> Source code in <code>codesurvey/analyzers/features.py</code> <pre><code>def feature_finder(name: str) -&gt; Callable[[FeatureFinderFunction[CodeReprT]], FeatureFinder[CodeReprT]]:\n\"\"\"Decorator for defining a named `FeatureFinder`.\n\n    Example usage:\n\n    ```python\n    @feature_finder('while')\n    def has_while(code_representation):\n        if code_representation is None:\n            return {'ignore': True}\n        return {\n            'occurrences': [\n                {'character_index': match.start()}\n                for match in re.finditer('test', str(code_representation))\n            ]\n        }\n    ```\n\n    \"\"\"\n\n    def decorator(func: FeatureFinderFunction[CodeReprT]) -&gt; FeatureFinder[CodeReprT]:\n\n        @wraps(func)\n        def decorated(*args, **kwargs):\n            feature = func(*args, **kwargs)\n            return _normalize_feature(name=name, feature=feature)\n\n        wrapped_feature_finder = cast(FeatureFinder[CodeReprT], decorated)\n        wrapped_feature_finder.name = name\n        return wrapped_feature_finder\n\n    return decorator\n</code></pre>"},{"location":"analyzers/features/#codesurvey.analyzers.partial_feature_finder","title":"<code>codesurvey.analyzers.partial_feature_finder(name, feature_finder_function, *args, **kwargs)</code>","text":"<p>Defines a FeatureFinder from the partial application of the given <code>feature_finder_function</code> with the given args and kwargs.</p> <p>Example usage:</p> <pre><code>has_math_module = partial_feature_finder('math_module', module_feature_finder, module='math')\n</code></pre> Source code in <code>codesurvey/analyzers/features.py</code> <pre><code>def partial_feature_finder(name: str,\n                           feature_finder_function: Callable[..., Union[Feature, FeatureDict]],\n                           *args, **kwargs) -&gt; FeatureFinder[CodeReprT]:\n\"\"\"Defines a FeatureFinder from the partial application of the given\n    `feature_finder_function` with the given args and kwargs.\n\n    Example usage:\n\n    ```python\n    has_math_module = partial_feature_finder('math_module', module_feature_finder, module='math')\n    ```\n\n    \"\"\"\n    return PartialFeatureFinder(\n        name=name,\n        feature_finder_function=feature_finder_function,\n        args=args,\n        kwargs=kwargs,\n    )\n</code></pre>"},{"location":"analyzers/features/#codesurvey.analyzers.union_feature_finder","title":"<code>codesurvey.analyzers.union_feature_finder(name, feature_finders)</code>","text":"<p>Defines a FeatureFinder that returns the union of the occurrences of the given <code>feature_finders</code>.</p> <p>The feature will only return an <code>'ignore'</code> result if all <code>feature_finders</code> ignore the given source-code unit.</p> <p>Example usage:</p> <pre><code>has_loop = union_feature_finder('loop', [has_for_loop, has_while_loop])\n</code></pre> Source code in <code>codesurvey/analyzers/features.py</code> <pre><code>def union_feature_finder(name: str, feature_finders: Sequence[FeatureFinder[CodeReprT]]) -&gt; FeatureFinder[CodeReprT]:\n\"\"\"Defines a FeatureFinder that returns the union of the occurrences\n    of the given `feature_finders`.\n\n    The feature will only return an `'ignore'` result if all\n    `feature_finders` ignore the given source-code unit.\n\n    Example usage:\n\n    ```python\n    has_loop = union_feature_finder('loop', [has_for_loop, has_while_loop])\n    ```\n\n    \"\"\"\n    return partial_feature_finder(name, _union_feature_finder, feature_finders=feature_finders)\n</code></pre>"},{"location":"analyzers/features/#core-classes","title":"Core Classes","text":""},{"location":"analyzers/features/#codesurvey.analyzers.FeatureFinder","title":"<code>codesurvey.analyzers.FeatureFinder</code>","text":"<p>             Bases: <code>Protocol</code>, <code>Generic[CodeReprInputT]</code></p> <p>Callable for producing a <code>Feature</code> analysis for a given source-code unit representation.</p> Source code in <code>codesurvey/analyzers/features.py</code> <pre><code>class FeatureFinder(Protocol, Generic[CodeReprInputT]):\n\"\"\"Callable for producing a [`Feature`][codesurvey.analyzers.Feature]\n    analysis for a given source-code unit representation.\"\"\"\n\n    name: str\n\"\"\"Name of the feature that is analyzed.\"\"\"\n\n    def __call__(self, code_repr: CodeReprInputT) -&gt; Feature:\n\"\"\"Analyze the given source-code unit representation.\"\"\"\n        pass\n</code></pre>"},{"location":"analyzers/features/#codesurvey.analyzers.FeatureFinder.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":"<p>Name of the feature that is analyzed.</p>"},{"location":"analyzers/features/#codesurvey.analyzers.FeatureFinder.__call__","title":"<code>__call__(code_repr: CodeReprInputT) -&gt; Feature</code>","text":"<p>Analyze the given source-code unit representation.</p> Source code in <code>codesurvey/analyzers/features.py</code> <pre><code>def __call__(self, code_repr: CodeReprInputT) -&gt; Feature:\n\"\"\"Analyze the given source-code unit representation.\"\"\"\n    pass\n</code></pre>"},{"location":"analyzers/features/#codesurvey.analyzers.Feature","title":"<code>codesurvey.analyzers.Feature</code>  <code>dataclass</code>","text":"<p>Analysis result of a single feature for a single source-code unit.</p> Source code in <code>codesurvey/analyzers/features.py</code> <pre><code>@dataclass\nclass Feature:\n\"\"\"Analysis result of a single feature for a single source-code unit.\"\"\"\n\n    name: str\n\"\"\"Name of the feature analyzed.\"\"\"\n\n    occurrences: Sequence[Dict[str, Any]] = field(default_factory=list)\n\"\"\"Occurrences of the feature within the source-code unit.\n\n    The data captured for each occurrence is determined by the\n    [`FeatureFinder`][codesurvey.analyzers.FeatureFinder] that\n    produced the Feature.\n\n    \"\"\"\n\n    ignore: bool = False\n\"\"\"If `True`, analysis of the feature was skipped for the source-code unit.\"\"\"\n</code></pre>"},{"location":"analyzers/features/#codesurvey.analyzers.Feature.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":"<p>Name of the feature analyzed.</p>"},{"location":"analyzers/features/#codesurvey.analyzers.Feature.occurrences","title":"<code>occurrences: Sequence[Dict[str, Any]] = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Occurrences of the feature within the source-code unit.</p> <p>The data captured for each occurrence is determined by the <code>FeatureFinder</code> that produced the Feature.</p>"},{"location":"analyzers/features/#codesurvey.analyzers.Feature.ignore","title":"<code>ignore: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>If <code>True</code>, analysis of the feature was skipped for the source-code unit.</p>"},{"location":"analyzers/python/","title":"Python Analyzers","text":"<p>The <code>PythonAstAnalyzer</code> can be used to analyze Python source code files. An <code>lxml.etree.Element</code> representation of each file's abstract syntax tree (AST) is passed to its <code>FeatureFinders</code> for analysis:</p>"},{"location":"analyzers/python/#codesurvey.analyzers.python.PythonAstAnalyzer","title":"<code>codesurvey.analyzers.python.PythonAstAnalyzer</code>","text":"<p>             Bases: <code>FileAnalyzer[Element]</code></p> <p>Analyzer that finds .py files and parses them into lxml documents representing Python abstract syntax trees for feature analysis.</p> Source code in <code>codesurvey/analyzers/python/core.py</code> <pre><code>class PythonAstAnalyzer(FileAnalyzer[Element]):\n\"\"\"Analyzer that finds .py files and parses them into lxml documents\n    representing Python abstract syntax trees for feature analysis.\"\"\"\n    default_name = 'python'\n    default_file_glob = '**/*.py'\n    default_file_filters = [\n        py_site_packages_filter,\n    ]\n\"\"\"Excludes files under a `site-packages` directory that are unlikely\n    to belong to the Repo under analysis.\"\"\"\n\n    def _subprocess_parse_ast(self, *, queue: Queue, file_text: str):\n        try:\n            file_tree = ast.parse(file_text)\n        except Exception as ex:\n            queue.put(ex)\n        else:\n            queue.put(file_tree)\n\n    def prepare_file(self, file_info: FileInfo) -&gt; Optional[Element]:\n        with open(file_info.abs_path, 'r') as f:\n            file_text = f.read()\n\n        # Parse ast in a subprocess, as sufficiently complex files can\n        # crash the interpreter:\n        # https://docs.python.org/3/library/ast.html#ast.parse\n        queue: Queue = Queue()\n        process = Process(target=self._subprocess_parse_ast, kwargs=dict(\n            queue=queue,\n            file_text=file_text,\n        ))\n        try:\n            process.start()\n            result = queue.get()\n            process.join()\n            if isinstance(result, Exception):\n                raise result\n        except (SyntaxError, ValueError) as ex:\n            logger.error((f'Skipping Python file \"{file_info.rel_path}\" in '\n                          f'repo \"{file_info.repo}\" that could not be parsed: {ex}'))\n            return None\n\n        file_tree = result\n        file_xml = astpath.convert_to_xml(file_tree)\n        return file_xml\n</code></pre>"},{"location":"analyzers/python/#codesurvey.analyzers.python.PythonAstAnalyzer.default_file_glob","title":"<code>default_file_glob = '**/*.py'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"analyzers/python/#codesurvey.analyzers.python.PythonAstAnalyzer.default_file_filters","title":"<code>default_file_filters = [py_site_packages_filter]</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Excludes files under a <code>site-packages</code> directory that are unlikely to belong to the Repo under analysis.</p>"},{"location":"analyzers/python/#codesurvey.analyzers.python.PythonAstAnalyzer.__init__","title":"<code>__init__(feature_finders: Sequence[FeatureFinder], *, file_glob: Optional[str] = None, file_filters: Optional[Sequence[Callable[[FileInfo], bool]]] = None, name: Optional[str] = None)</code>","text":"<p>Parameters:</p> <ul> <li> feature_finders             (<code>Sequence[FeatureFinder]</code>)         \u2013          <p>The FeatureFinders for analyzing each source-code file.</p> </li> <li> file_glob             (<code>Optional[str]</code>, default:                 <code>None</code> )         \u2013          <p>Glob pattern for finding source-code files within the Repo.</p> </li> <li> file_filters             (<code>Optional[Sequence[Callable[[FileInfo], bool]]]</code>, default:                 <code>None</code> )         \u2013          <p>Filters to identify files to exclude from analysis. Each filter is a function that takes a <code>FileInfo</code> and returns <code>True</code> if the file should be excluded. file_filters cannot be lambdas, as they need to be pickled when passed to sub-processes.</p> </li> <li> name             (<code>Optional[str]</code>, default:                 <code>None</code> )         \u2013          <p>Name to identify the Analyzer. If <code>None</code>, defaults to the Analyzer type's default_name.</p> </li> </ul> Source code in <code>codesurvey/analyzers/core.py</code> <pre><code>def __init__(self, feature_finders: Sequence[FeatureFinder], *,\n             file_glob: Optional[str] = None,\n             file_filters: Optional[Sequence[Callable[[FileInfo], bool]]] = None,\n             name: Optional[str] = None):\n\"\"\"\n    Args:\n        feature_finders:\n            The [FeatureFinders][codesurvey.analyzers.FeatureFinder]\n            for analyzing each source-code file.\n        file_glob: Glob pattern for finding source-code files within\n            the Repo.\n        file_filters: Filters to identify files to exclude from analysis.\n            Each filter is a function that takes a\n            [`FileInfo`][codesurvey.analyzers.FileInfo] and\n            returns `True` if the file should be excluded. file_filters\n            cannot be lambdas, as they need to be pickled when passed to\n            sub-processes.\n        name: Name to identify the Analyzer. If `None`, defaults to the\n            Analyzer type's default_name.\n\n    \"\"\"\n    super().__init__(feature_finders=feature_finders, name=name)\n    self.file_glob = self.default_file_glob if file_glob is None else file_glob\n    self.file_filters = self.default_file_filters if file_filters is None else file_filters\n</code></pre>"},{"location":"analyzers/python/#codesurvey.analyzers.python.PythonAstAnalyzer.test","title":"<code>test(code_snippet: str, *, test_filename: str = 'test_file.txt') -&gt; Dict[str, Feature]</code>","text":"<p>Utility for directly analyzing a string of source-code.</p> <p>A Repo will be created in a temporary directory to perform analysis of a file created with the given <code>code_snippet</code>.</p> <p>Parameters:</p> <ul> <li> code_snippet             (<code>str</code>)         \u2013          <p>String of source-code to analyze.</p> </li> <li> test_filename             (<code>str</code>, default:                 <code>'test_file.txt'</code> )         \u2013          <p>Optional custom filename used for the test file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict[str, Feature]</code>         \u2013          <p>A dictionary mapping feature names to <code>Feature</code> results.</p> </li> </ul> Source code in <code>codesurvey/analyzers/core.py</code> <pre><code>def test(self, code_snippet: str, *, test_filename: str = 'test_file.txt') -&gt; Dict[str, Feature]:\n\"\"\"Utility for directly analyzing a string of source-code.\n\n    A Repo will be created in a temporary directory to perform\n    analysis of a file created with the given `code_snippet`.\n\n    Args:\n        code_snippet: String of source-code to analyze.\n        test_filename: Optional custom filename used for the test file.\n\n    Returns:\n        A dictionary mapping feature names to\n            [`Feature`][codesurvey.analyzers.Feature] results.\n\n    \"\"\"\n    source = TestSource({test_filename: code_snippet})\n    repo = next(source.repo_generator())\n    code = self.analyze_code(\n        repo=repo,\n        code_key=test_filename,\n        features=self.get_feature_names(),\n    )\n    return code.features\n</code></pre>"},{"location":"analyzers/python/#built-in-feature-finders","title":"Built-In Feature Finders","text":"<p>CodeSurvey comes equipped with the following <code>FeatureFinders</code> that can be used with <code>PythonAstAnalyzer</code>:</p>"},{"location":"analyzers/python/#codesurvey.analyzers.python.features.has_for_else","title":"<code>has_for_else</code>","text":"<p>FeatureFinder for else clauses in for loops.</p> Source code in <code>codesurvey/analyzers/python/features.py</code> <pre><code>@py_ast_feature_finder_with_transform('for_else', xpath='For/orelse')\ndef has_for_else(orelse_el):\n\"\"\"FeatureFinder for else clauses in for loops.\"\"\"\n    if len(orelse_el) == 0:\n        return None\n    return orelse_el\n</code></pre>"},{"location":"analyzers/python/#codesurvey.analyzers.python.features.has_try_finally","title":"<code>has_try_finally</code>","text":"<p>FeatureFinder for finally clauses in try statements.</p> Source code in <code>codesurvey/analyzers/python/features.py</code> <pre><code>@py_ast_feature_finder_with_transform('try_finally', xpath='Try/finalbody')\ndef has_try_finally(finalbody_el):\n\"\"\"FeatureFinder for finally clauses in try statements.\"\"\"\n    if len(finalbody_el) == 0:\n        return None\n    return finalbody_el\n</code></pre>"},{"location":"analyzers/python/#codesurvey.analyzers.python.features.has_type_hint","title":"<code>has_type_hint</code>","text":"<p>FeatureFinder for type hints.</p> Source code in <code>codesurvey/analyzers/python/features.py</code> <pre><code>@py_ast_feature_finder_with_transform('type_hint', xpath='FunctionDef/args/arguments//annotation')\ndef has_type_hint(annotation_el):\n\"\"\"FeatureFinder for type hints.\"\"\"\n    if annotation_el.get('*') is not None:\n        return annotation_el\n    return None\n</code></pre>"},{"location":"analyzers/python/#codesurvey.analyzers.python.features.has_set_function","title":"<code>has_set_function</code>","text":"<p>FeatureFinder for the set function.</p> Source code in <code>codesurvey/analyzers/python/features.py</code> <pre><code>@py_ast_feature_finder_with_transform('set_function', xpath='Call/func/Name')\ndef has_set_function(func_name_el):\n\"\"\"FeatureFinder for the set function.\"\"\"\n    if func_name_el.get('id') == 'set':\n        return func_name_el\n    return None\n</code></pre>"},{"location":"analyzers/python/#codesurvey.analyzers.python.features.has_set_value","title":"<code>has_set_value = py_ast_feature_finder('set_value', xpath='Set')</code>  <code>module-attribute</code>","text":"<p>FeatureFinder for set literals.</p>"},{"location":"analyzers/python/#codesurvey.analyzers.python.features.has_set","title":"<code>has_set = union_feature_finder('set', [has_set_function, has_set_value])</code>  <code>module-attribute</code>","text":"<p>FeatureFinder for sets.</p>"},{"location":"analyzers/python/#codesurvey.analyzers.python.features.has_fstring","title":"<code>has_fstring = py_ast_feature_finder('fstring', xpath='FormattedValue')</code>  <code>module-attribute</code>","text":"<p>FeatureFinder for f-strings.</p>"},{"location":"analyzers/python/#codesurvey.analyzers.python.features.has_ternary","title":"<code>has_ternary = py_ast_feature_finder('ternary', xpath='IfExp')</code>  <code>module-attribute</code>","text":"<p>FeatureFinder for ternary expressions.</p>"},{"location":"analyzers/python/#codesurvey.analyzers.python.features.has_pattern_matching","title":"<code>has_pattern_matching = py_ast_feature_finder('pattern_matching', xpath='Match')</code>  <code>module-attribute</code>","text":"<p>FeatureFinder for pattern matching.</p>"},{"location":"analyzers/python/#codesurvey.analyzers.python.features.has_walrus","title":"<code>has_walrus = py_ast_feature_finder('walrus', xpath='NamedExpr')</code>  <code>module-attribute</code>","text":"<p>FeatureFinder for the walrus operator.</p>"},{"location":"analyzers/python/#custom-python-feature-finders","title":"Custom Python Feature Finders","text":"<p>The following utilities can be used to define simple <code>FeatureFinders</code> that can be used with <code>PythonAstAnalyzer</code> to analyze Python abstract syntax trees:</p>"},{"location":"analyzers/python/#codesurvey.analyzers.python.py_ast_feature_finder","title":"<code>codesurvey.analyzers.python.py_ast_feature_finder(name: str, *, xpath: str) -&gt; FeatureFinder[lxml.etree.Element]</code>","text":"<p>Defines a FeatureFinder that looks for elements in a Python AST matching the given xpath query.</p> <p>To explore the AST structure of the code constructs you are interested in identifying, consider using a tool like: https://python-ast-explorer.com/</p> Source code in <code>codesurvey/analyzers/python/features.py</code> <pre><code>def py_ast_feature_finder(name: str, *, xpath: str) -&gt; FeatureFinder[lxml.etree.Element]:\n\"\"\"Defines a FeatureFinder that looks for elements in a Python AST\n    matching the given xpath query.\n\n    To explore the AST structure of the code constructs you are\n    interested in identifying, consider using a tool like:\n    https://python-ast-explorer.com/\n\n    \"\"\"\n    return partial_feature_finder(name, _py_ast_feature_finder, xpath=xpath)\n</code></pre>"},{"location":"analyzers/python/#codesurvey.analyzers.python.py_ast_feature_finder_with_transform","title":"<code>codesurvey.analyzers.python.py_ast_feature_finder_with_transform(name: str, *, xpath: str) -&gt; Callable[[ElementTransform], FeatureFinder[lxml.etree.Element]]</code>","text":"<p>Decorator for defining a FeatureFinder that looks for elements in a Python AST matching the given xpath query, transforming found elements with decorated function.</p> <p>The function should receive and return an <code>lxml.etree.Element</code>, or return <code>None</code> if the element should not be considered an occurrence of the feature.</p> <p>Example usage to look for function calls where the function name is 'set':</p> <pre><code>@py_ast_feature_finder_with_transform('set_function', xpath='Call/func/Name')\ndef has_set_function(func_name_el):\n    if func_name_el.get('id') == 'set':\n        return func_name_el\n    return None\n</code></pre> <p>To explore the AST structure of the code constructs you are interested in identifying, consider using a tool like: https://python-ast-explorer.com/</p> Source code in <code>codesurvey/analyzers/python/features.py</code> <pre><code>def py_ast_feature_finder_with_transform(name: str, *, xpath: str) -&gt; Callable[[ElementTransform], FeatureFinder[lxml.etree.Element]]:\n\"\"\"Decorator for defining a FeatureFinder that looks for elements in a\n    Python AST matching the given xpath query, transforming found elements\n    with decorated function.\n\n    The function should receive and return an `lxml.etree.Element`, or\n    return `None` if the element should not be considered an\n    occurrence of the feature.\n\n    Example usage to look for function calls where the function name\n    is 'set':\n\n    ```python\n    @py_ast_feature_finder_with_transform('set_function', xpath='Call/func/Name')\n    def has_set_function(func_name_el):\n        if func_name_el.get('id') == 'set':\n            return func_name_el\n        return None\n    ```\n\n    To explore the AST structure of the code constructs you are\n    interested in identifying, consider using a tool like:\n    https://python-ast-explorer.com/\n\n    \"\"\"\n\n    def decorator(func: ElementTransform) -&gt; FeatureFinder[lxml.etree.Element]:\n\n        @wraps(func)\n        @feature_finder(name)\n        def decorated(xml):\n            return _py_ast_feature_finder(xml, xpath=xpath, transform=func)\n\n        return decorated\n\n    return decorator\n</code></pre>"},{"location":"analyzers/python/#codesurvey.analyzers.python.py_module_feature_finder","title":"<code>codesurvey.analyzers.python.py_module_feature_finder(name: str, *, modules: Sequence[str]) -&gt; FeatureFinder</code>","text":"<p>Defines a FeatureFinder that looks for import statements of one or more target Python <code>modules</code>.</p> <p>Example usage:</p> <pre><code>has_dataclasses = py_module_feature_finder('dataclasses_module', modules=['dataclasses'])\n</code></pre> Source code in <code>codesurvey/analyzers/python/features.py</code> <pre><code>def py_module_feature_finder(name: str, *, modules: Sequence[str]) -&gt; FeatureFinder:\n\"\"\"Defines a FeatureFinder that looks for import statements of one or\n    more target Python `modules`.\n\n    Example usage:\n\n    ```python\n    has_dataclasses = py_module_feature_finder('dataclasses_module', modules=['dataclasses'])\n    ```\n\n    \"\"\"\n    return partial_feature_finder(name, _py_module_feature_finder, modules=modules)\n</code></pre>"},{"location":"sources/core/","title":"Core Sources","text":"<p>The purpose of a <code>Source</code> is to provide CodeSurvey with repositories of code (referred to as Repos) to analyze. A <code>Source</code> may retrieve code from specific local directories or remote repositories, or may use APIs to sample repositories from a large pool, such as from code-hosting platforms like GitHub.</p>"},{"location":"sources/core/#built-in-sources","title":"Built-In Sources","text":"<p>CodeSurvey provides the following built-in Sources for you to survey code from common types of code repositories:</p>"},{"location":"sources/core/#codesurvey.sources.LocalSource","title":"<code>codesurvey.sources.LocalSource</code>","text":"<p>             Bases: <code>Source</code></p> <p>Source of Repos from local filesystem directories.</p> <p>Example usage:</p> <pre><code>LocalSource([\n    'path/to/my-source-code-directory',\n])\n</code></pre> Source code in <code>codesurvey/sources/core.py</code> <pre><code>class LocalSource(Source):\n\"\"\"\n    Source of Repos from local filesystem directories.\n\n    Example usage:\n\n    ```python\n    LocalSource([\n        'path/to/my-source-code-directory',\n    ])\n    ```\n\n    \"\"\"\n    default_name = 'local'\n\n    def __init__(self, dirs: Sequence[str], *, name: Optional[str] = None):\n\"\"\"\n        Args:\n            dirs: Paths to the local source code directory of each Repo\n            name: Name to identify the Source. If `None`, defaults to 'local'.\n        \"\"\"\n        self.dirs = dirs\n        super().__init__(name=name)\n\n    def fetch_repo(self, repo_key: str) -&gt; Repo:\n        return self.repo(\n            key=repo_key,\n            path=repo_key,\n        )\n\n    def repo_generator(self) -&gt; Iterator[Repo]:\n        for repo_dir in self.dirs:\n            yield self.fetch_repo(repo_dir)\n</code></pre>"},{"location":"sources/core/#codesurvey.sources.LocalSource.__init__","title":"<code>__init__(dirs: Sequence[str], *, name: Optional[str] = None)</code>","text":"<p>Parameters:</p> <ul> <li> dirs             (<code>Sequence[str]</code>)         \u2013          <p>Paths to the local source code directory of each Repo</p> </li> <li> name             (<code>Optional[str]</code>, default:                 <code>None</code> )         \u2013          <p>Name to identify the Source. If <code>None</code>, defaults to 'local'.</p> </li> </ul> Source code in <code>codesurvey/sources/core.py</code> <pre><code>def __init__(self, dirs: Sequence[str], *, name: Optional[str] = None):\n\"\"\"\n    Args:\n        dirs: Paths to the local source code directory of each Repo\n        name: Name to identify the Source. If `None`, defaults to 'local'.\n    \"\"\"\n    self.dirs = dirs\n    super().__init__(name=name)\n</code></pre>"},{"location":"sources/core/#codesurvey.sources.GitSource","title":"<code>codesurvey.sources.GitSource</code>","text":"<p>             Bases: <code>Source</code></p> <p>Source of Repos from remote Git repositories.</p> <p>Repos are downloaded into a local directory for analysis.</p> <p>Example usage:</p> <pre><code>GitSource([\n    'https://github.com/whenofpython/codesurvey',\n])\n</code></pre> Source code in <code>codesurvey/sources/core.py</code> <pre><code>class GitSource(Source):\n\"\"\"\n    Source of Repos from remote Git repositories.\n\n    Repos are downloaded into a local directory for analysis.\n\n    Example usage:\n\n    ```python\n    GitSource([\n        'https://github.com/whenofpython/codesurvey',\n    ])\n    ```\n\n    \"\"\"\n    default_name = 'git'\n\n    def __init__(self, repo_urls: Sequence[str], *, name: Optional[str] = None):\n\"\"\"\n        Args:\n            repo_urls: URLs of remote Git repositories.\n            name: Name to identify the Source. If `None`, defaults to 'git'.\n        \"\"\"\n        self.repo_urls = repo_urls\n        super().__init__(name=name)\n\n    def fetch_repo(self, repo_key: str) -&gt; Repo:\n        try:\n            temp_dir = fetch_git_repo(repo_key)\n        except SourceError as ex:\n            raise SourceError(f'Source {self} failed to clone from GitHub: {ex}')\n        return self.repo(\n            key=repo_key,\n            path=temp_dir,\n            # When the repo is finished being used, the temp_dir\n            # should be deleted:\n            cleanup=partial(TemporaryDirectory._rmtree, temp_dir),  # type: ignore[attr-defined]\n        )\n\n    def repo_generator(self) -&gt; Iterator[RepoThunk]:\n        for repo_url in self.repo_urls:\n            yield self.repo_thunk(\n                key=repo_url,\n                thunk=partial(self.fetch_repo, repo_url),\n            )\n</code></pre>"},{"location":"sources/core/#codesurvey.sources.GitSource.__init__","title":"<code>__init__(repo_urls: Sequence[str], *, name: Optional[str] = None)</code>","text":"<p>Parameters:</p> <ul> <li> repo_urls             (<code>Sequence[str]</code>)         \u2013          <p>URLs of remote Git repositories.</p> </li> <li> name             (<code>Optional[str]</code>, default:                 <code>None</code> )         \u2013          <p>Name to identify the Source. If <code>None</code>, defaults to 'git'.</p> </li> </ul> Source code in <code>codesurvey/sources/core.py</code> <pre><code>def __init__(self, repo_urls: Sequence[str], *, name: Optional[str] = None):\n\"\"\"\n    Args:\n        repo_urls: URLs of remote Git repositories.\n        name: Name to identify the Source. If `None`, defaults to 'git'.\n    \"\"\"\n    self.repo_urls = repo_urls\n    super().__init__(name=name)\n</code></pre>"},{"location":"sources/core/#codesurvey.sources.GithubSampleSource","title":"<code>codesurvey.sources.GithubSampleSource</code>","text":"<p>             Bases: <code>Source</code></p> <p>Source of Repos sampled from GitHub's search API.</p> <p>Repos are sampled from randomly selected pages of GitHub search results, and downloaded to a temporary directory for analysis.</p> <p>For explanations of GitHub search parameters, see: https://docs.github.com/en/free-pro-team@latest/rest/search/search#search-repositories</p> <p>GitHub authentication credentials can be provided to increase rate limits. See: https://docs.github.com/en/rest/overview/authenticating-to-the-rest-api</p> <p>Example usage:</p> <pre><code>GithubSampleSource(language='python')\n</code></pre> Source code in <code>codesurvey/sources/core.py</code> <pre><code>class GithubSampleSource(Source):\n\"\"\"Source of Repos sampled from GitHub's search API.\n\n    Repos are sampled from randomly selected pages of GitHub search\n    results, and downloaded to a temporary directory for analysis.\n\n    For explanations of GitHub search parameters, see:\n    https://docs.github.com/en/free-pro-team@latest/rest/search/search#search-repositories\n\n    GitHub authentication credentials can be provided to increase rate\n    limits. See:\n    https://docs.github.com/en/rest/overview/authenticating-to-the-rest-api\n\n    Example usage:\n\n    ```python\n    GithubSampleSource(language='python')\n    ```\n\n    \"\"\"\n    default_name = 'github_sample'\n\n    REPOS_PER_PAGE = 100\n    # GitHub only returns the first 1,000 search results\n    MAX_RESULTS = 1000\n\n    def __init__(self, *,\n                 search_query: str = '',\n                 language: Optional[str],\n                 max_kb: Optional[int] = 50_000,\n                 sort: str = 'updated',\n                 auth_username: Optional[str] = None,\n                 auth_token: Optional[str] = None,\n                 random_seed: Optional[int] = None,\n                 name: Optional[str] = None):\n\"\"\"\n        Args:\n            search_query: An optional search query for GitHub search.\n            language: An optional constraint for GitHub's repository\n                language tag.\n            max_kb: To avoid downloading excessively large repositories,\n                limits the maximum kilobyte size of sampled Repos.\n            sort: Sort order for GitHub search. Important as GitHub will\n                only return the first 1000 pages of search results to sample\n                from. Defaults to searching for recently updated repositories.\n            auth_username: Username for GitHub authentication.\n            auth_token: Token for GitHub authentication.\n            random_seed: Random seed for sampling pages of search results.\n                If `None`, a randomly selected seed is used.\n            name: Name to identify the Source. If `None`, defaults\n                to 'github_sample'.\n        \"\"\"\n        self.search_query = search_query\n        self.language = language\n        self.max_kb = max_kb\n        self.sort = sort\n        self.auth = (auth_username, auth_token) if auth_username and auth_token else None\n        self.random_seed = random_seed\n        super().__init__(name=name)\n\n    def _search_repos(self, *, page: int = 1) -&gt; dict:\n\"\"\"\n        Makes a GitHub repo search API call for the specified page index.\n\n        Returns a dictionary containing result metadata (total number of pages)\n        and a list of dictionaries containing metadata for found repos.\n\n        See:\n\n        * https://docs.github.com/en/rest/search#search-repositories\n        * https://docs.github.com/en/search-github/searching-on-github/searching-for-repositories\n        \"\"\"\n        q_parts = []\n        if self.search_query:\n            q_parts.append(self.search_query)\n        if self.language is not None:\n            q_parts.append(f'language:{self.language}')\n        if self.max_kb is not None:\n            q_parts.append(f'size:&lt;={self.max_kb}')\n\n        params: Dict[str, Union[str, int]] = {\n            'q': ' '.join(q_parts),\n            'sort': self.sort,\n            'per_page': self.REPOS_PER_PAGE,\n            'page': page,\n        }\n\n        r = requests.get(\n            'https://api.github.com/search/repositories',\n            auth=self.auth,\n            params=params,\n        )\n        r_json = r.json()\n        return {\n            # Return the total number of result pages that can be\n            # sampled from.\n            'page_count': max(self.MAX_RESULTS, r_json['total_count']) / self.REPOS_PER_PAGE,\n            # Restrict the list of returned repos to those that\n            # have the (optionally) specified language.\n            'repos': [\n                item for item in r_json['items']\n                if (self.language is None or (str(item['language']).lower() == self.language))\n            ],\n        }\n\n    def _clone_repo(self, repo_data: dict) -&gt; Repo:\n\"\"\"Helper to clone a Git repository given repo_data from the GitHub repos API.\"\"\"\n        try:\n            temp_dir = fetch_git_repo(repo_data['clone_url'])\n        except SourceError as ex:\n            raise SourceError(f'Source {self} failed to clone from GitHub: {ex}')\n        return self.repo(\n            key=repo_data['full_name'],\n            path=temp_dir,\n            # When the repo is finished being used, the temp_dir\n            # should be deleted:\n            cleanup=partial(TemporaryDirectory._rmtree, temp_dir),  # type: ignore[attr-defined]\n            metadata={\n                'stars': repo_data['stargazers_count'],\n            },\n        )\n\n    def fetch_repo(self, repo_key: str) -&gt; Repo:\n        r = requests.get(\n            'https://api.github.com/repos/{repo_key}',\n            auth=self.auth,\n        )\n        return self._clone_repo(r.json())\n\n    def repo_generator(self) -&gt; Iterator[RepoThunk]:\n        rng = Random(self.random_seed)\n        page_count = 1\n        while True:\n            logger.info(f'Source \"{self}\" searching GitHub for repos')\n            search_result = self._search_repos(page=rng.randint(1, page_count))\n            page_count = search_result['page_count']\n            for repo_data in search_result['repos']:\n                yield self.repo_thunk(\n                    key=repo_data['full_name'],\n                    thunk=partial(self._clone_repo, repo_data),\n                )\n</code></pre>"},{"location":"sources/core/#codesurvey.sources.GithubSampleSource.__init__","title":"<code>__init__(*, search_query: str = '', language: Optional[str], max_kb: Optional[int] = 50000, sort: str = 'updated', auth_username: Optional[str] = None, auth_token: Optional[str] = None, random_seed: Optional[int] = None, name: Optional[str] = None)</code>","text":"<p>Parameters:</p> <ul> <li> search_query             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>An optional search query for GitHub search.</p> </li> <li> language             (<code>Optional[str]</code>)         \u2013          <p>An optional constraint for GitHub's repository language tag.</p> </li> <li> max_kb             (<code>Optional[int]</code>, default:                 <code>50000</code> )         \u2013          <p>To avoid downloading excessively large repositories, limits the maximum kilobyte size of sampled Repos.</p> </li> <li> sort             (<code>str</code>, default:                 <code>'updated'</code> )         \u2013          <p>Sort order for GitHub search. Important as GitHub will only return the first 1000 pages of search results to sample from. Defaults to searching for recently updated repositories.</p> </li> <li> auth_username             (<code>Optional[str]</code>, default:                 <code>None</code> )         \u2013          <p>Username for GitHub authentication.</p> </li> <li> auth_token             (<code>Optional[str]</code>, default:                 <code>None</code> )         \u2013          <p>Token for GitHub authentication.</p> </li> <li> random_seed             (<code>Optional[int]</code>, default:                 <code>None</code> )         \u2013          <p>Random seed for sampling pages of search results. If <code>None</code>, a randomly selected seed is used.</p> </li> <li> name             (<code>Optional[str]</code>, default:                 <code>None</code> )         \u2013          <p>Name to identify the Source. If <code>None</code>, defaults to 'github_sample'.</p> </li> </ul> Source code in <code>codesurvey/sources/core.py</code> <pre><code>def __init__(self, *,\n             search_query: str = '',\n             language: Optional[str],\n             max_kb: Optional[int] = 50_000,\n             sort: str = 'updated',\n             auth_username: Optional[str] = None,\n             auth_token: Optional[str] = None,\n             random_seed: Optional[int] = None,\n             name: Optional[str] = None):\n\"\"\"\n    Args:\n        search_query: An optional search query for GitHub search.\n        language: An optional constraint for GitHub's repository\n            language tag.\n        max_kb: To avoid downloading excessively large repositories,\n            limits the maximum kilobyte size of sampled Repos.\n        sort: Sort order for GitHub search. Important as GitHub will\n            only return the first 1000 pages of search results to sample\n            from. Defaults to searching for recently updated repositories.\n        auth_username: Username for GitHub authentication.\n        auth_token: Token for GitHub authentication.\n        random_seed: Random seed for sampling pages of search results.\n            If `None`, a randomly selected seed is used.\n        name: Name to identify the Source. If `None`, defaults\n            to 'github_sample'.\n    \"\"\"\n    self.search_query = search_query\n    self.language = language\n    self.max_kb = max_kb\n    self.sort = sort\n    self.auth = (auth_username, auth_token) if auth_username and auth_token else None\n    self.random_seed = random_seed\n    super().__init__(name=name)\n</code></pre>"},{"location":"sources/core/#codesurvey.sources.TestSource","title":"<code>codesurvey.sources.TestSource</code>","text":"<p>             Bases: <code>Source</code></p> <p>Creates a single Repo in a temporary directory with specified files and contents.</p> <p>Only use with trusted paths, as paths are not checked for absolute or parent directory navigation.</p> Source code in <code>codesurvey/sources/core.py</code> <pre><code>class TestSource(Source):\n\"\"\"Creates a single Repo in a temporary directory with specified files\n    and contents.\n\n    Only use with trusted paths, as paths are not checked for absolute\n    or parent directory navigation.\n\n    \"\"\"\n    default_name = 'test'\n\n    def __init__(self, path_to_content: Mapping[str, str], *, name: Optional[str] = None):\n\"\"\"\n        Args:\n            path_to_content: Mapping of paths to contents for files to create\n                in a test Repo directory\n            name: Name to identify the Source. If `None`, defaults to 'test'.\n        \"\"\"\n        self.path_to_content = path_to_content\n        super().__init__(name=name)\n\n    def fetch_repo(self, repo_key: str) -&gt; Repo:\n        return self.repo(\n            key=repo_key,\n            path=repo_key,\n            # When the repo is finished being used, the temporary\n            # directory should be deleted:\n            cleanup=partial(TemporaryDirectory._rmtree, repo_key),  # type: ignore[attr-defined]\n        )\n\n    def repo_generator(self) -&gt; Iterator[Repo]:\n        temp_dir = mkdtemp()\n        for path, content in self.path_to_content.items():\n            path_head, path_tail = os.path.split(path)\n            path_dir = os.path.join(temp_dir, path_head)\n            os.makedirs(path_dir, exist_ok=True)\n            with open(os.path.join(path_dir, path_tail), 'w') as path_file:\n                path_file.write(content)\n        yield self.fetch_repo(temp_dir)\n</code></pre>"},{"location":"sources/core/#codesurvey.sources.TestSource.__init__","title":"<code>__init__(path_to_content: Mapping[str, str], *, name: Optional[str] = None)</code>","text":"<p>Parameters:</p> <ul> <li> path_to_content             (<code>Mapping[str, str]</code>)         \u2013          <p>Mapping of paths to contents for files to create in a test Repo directory</p> </li> <li> name             (<code>Optional[str]</code>, default:                 <code>None</code> )         \u2013          <p>Name to identify the Source. If <code>None</code>, defaults to 'test'.</p> </li> </ul> Source code in <code>codesurvey/sources/core.py</code> <pre><code>def __init__(self, path_to_content: Mapping[str, str], *, name: Optional[str] = None):\n\"\"\"\n    Args:\n        path_to_content: Mapping of paths to contents for files to create\n            in a test Repo directory\n        name: Name to identify the Source. If `None`, defaults to 'test'.\n    \"\"\"\n    self.path_to_content = path_to_content\n    super().__init__(name=name)\n</code></pre>"},{"location":"sources/core/#custom-sources","title":"Custom Sources","text":"<p>You can define your own Source to provide Repos from other storage providers, platforms or APIs. Simply define a class that inherits from <code>Source</code> and defines <code>fetch_repo()</code> and <code>repo_generator()</code> methods that return Repos, or RepoThunks that can be executed in a parallelizable sub-process in order to prepare a Repo.</p> <p>Your Source should also specify a <code>default_name</code> class attribute that will be used to identify your Source in logs and results (except where a name is provided for a specific Source instance).</p> <p>For example, to define a custom Source that recieves a <code>custom_arg</code> and directly returns Repos:</p> <pre><code>class CustomSource(Source):\n    default_name = 'custom'\n\n    def __init__(self, custom_arg, *, name: Optional[str] = None):\n        self.custom_arg = custom_arg\n        super().__init__(name=name)\n\n    def fetch_repo(self, repo_key: str) -&gt; Repo:\n        repo_path = # TODO\n        return self.repo(\n            key=repo_key,\n            path=repo_path,\n        )\n\n    def repo_generator(self) -&gt; Iterator[Repo]:\n        while True:\n            repo_key = # TODO\n            yield self.fetch_repo(repo_key)\n</code></pre> <p>Alternatively, your custom Source can delay downloading or otherwise preparing a Repo to a parallelizable sub-process by yielding RepoThunks from <code>repo_generator()</code>:</p> <pre><code>def repo_generator(self) -&gt; Iterator[RepoThunk]:\n    while True:\n        repo_key = # TODO\n        yield self.repo_thunk(\n            key=repo_key,\n            thunk=functools.partial(self.fetch_repo, repo_key),\n        )\n</code></pre>"},{"location":"sources/core/#core-classes","title":"Core Classes","text":""},{"location":"sources/core/#codesurvey.sources.Source","title":"<code>codesurvey.sources.Source</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Provides Repos to be anaylyzed by CodeSurvey.</p> Source code in <code>codesurvey/sources/core.py</code> <pre><code>class Source(ABC):\n\"\"\"Provides Repos to be anaylyzed by CodeSurvey.\"\"\"\n\n    default_name: str\n\"\"\"Default name to be assigned to Sources of this type if a custom\n    name is not specified.\"\"\"\n\n    def __init__(self, *, name: Optional[str] = None):\n\"\"\"\n        Args:\n            name: Name to identify the Source. If `None`, defaults to the\n                Source type's default_name\n        \"\"\"\n        self.name = self.default_name if name is None else name\n        if self.name is None:\n            raise ValueError('Analyzer name cannot be None')\n\n    @abstractmethod\n    def fetch_repo(self, repo_key: str) -&gt; Repo:\n\"\"\"Prepares the [Repo][codesurvey.sources.Repo] with the given\n        `repo_key` for analysis.\n\n        Typically called internally by repo_generator or by a\n        RepoThunk, but also useful for inspecting a Repo given it's\n        key from a survey result.\n\n        \"\"\"\n\n    @abstractmethod\n    def repo_generator(self) -&gt; Iterator[Union[Repo, RepoThunk]]:\n\"\"\"Generator yielding [Repos][codesurvey.sources.Repo] ready for\n        analysis or [RepoThunks][codesurvey.sources.RepoThunk] that\n        can be executed to prepare them for analysis.\"\"\"\n\n    def __str__(self):\n        return self.name\n\n    def __repr__(self):\n        return f'{self.__class__.__name__}({self})'\n\n    def repo(self, **kwargs):\n\"\"\"Internal helper to generate a Repo for this Source. Takes the same\n        arguments as Repo except for source.\"\"\"\n        return Repo(source=self, **kwargs)\n\n    def repo_thunk(self, **kwargs):\n\"\"\"Internal helper to generate a RepoThunk for this Source. Takes the\n        same arguments as RepoThunk except for source.\"\"\"\n        return RepoThunk(source=self, **kwargs)\n</code></pre>"},{"location":"sources/core/#codesurvey.sources.Source.default_name","title":"<code>default_name: str</code>  <code>instance-attribute</code>","text":"<p>Default name to be assigned to Sources of this type if a custom name is not specified.</p>"},{"location":"sources/core/#codesurvey.sources.Source.__init__","title":"<code>__init__(*, name: Optional[str] = None)</code>","text":"<p>Parameters:</p> <ul> <li> name             (<code>Optional[str]</code>, default:                 <code>None</code> )         \u2013          <p>Name to identify the Source. If <code>None</code>, defaults to the Source type's default_name</p> </li> </ul> Source code in <code>codesurvey/sources/core.py</code> <pre><code>def __init__(self, *, name: Optional[str] = None):\n\"\"\"\n    Args:\n        name: Name to identify the Source. If `None`, defaults to the\n            Source type's default_name\n    \"\"\"\n    self.name = self.default_name if name is None else name\n    if self.name is None:\n        raise ValueError('Analyzer name cannot be None')\n</code></pre>"},{"location":"sources/core/#codesurvey.sources.Source.fetch_repo","title":"<code>fetch_repo(repo_key: str) -&gt; Repo</code>  <code>abstractmethod</code>","text":"<p>Prepares the Repo with the given <code>repo_key</code> for analysis.</p> <p>Typically called internally by repo_generator or by a RepoThunk, but also useful for inspecting a Repo given it's key from a survey result.</p> Source code in <code>codesurvey/sources/core.py</code> <pre><code>@abstractmethod\ndef fetch_repo(self, repo_key: str) -&gt; Repo:\n\"\"\"Prepares the [Repo][codesurvey.sources.Repo] with the given\n    `repo_key` for analysis.\n\n    Typically called internally by repo_generator or by a\n    RepoThunk, but also useful for inspecting a Repo given it's\n    key from a survey result.\n\n    \"\"\"\n</code></pre>"},{"location":"sources/core/#codesurvey.sources.Source.repo_generator","title":"<code>repo_generator() -&gt; Iterator[Union[Repo, RepoThunk]]</code>  <code>abstractmethod</code>","text":"<p>Generator yielding Repos ready for analysis or RepoThunks that can be executed to prepare them for analysis.</p> Source code in <code>codesurvey/sources/core.py</code> <pre><code>@abstractmethod\ndef repo_generator(self) -&gt; Iterator[Union[Repo, RepoThunk]]:\n\"\"\"Generator yielding [Repos][codesurvey.sources.Repo] ready for\n    analysis or [RepoThunks][codesurvey.sources.RepoThunk] that\n    can be executed to prepare them for analysis.\"\"\"\n</code></pre>"},{"location":"sources/core/#codesurvey.sources.Source.repo","title":"<code>repo(**kwargs)</code>","text":"<p>Internal helper to generate a Repo for this Source. Takes the same arguments as Repo except for source.</p> Source code in <code>codesurvey/sources/core.py</code> <pre><code>def repo(self, **kwargs):\n\"\"\"Internal helper to generate a Repo for this Source. Takes the same\n    arguments as Repo except for source.\"\"\"\n    return Repo(source=self, **kwargs)\n</code></pre>"},{"location":"sources/core/#codesurvey.sources.Source.repo_thunk","title":"<code>repo_thunk(**kwargs)</code>","text":"<p>Internal helper to generate a RepoThunk for this Source. Takes the same arguments as RepoThunk except for source.</p> Source code in <code>codesurvey/sources/core.py</code> <pre><code>def repo_thunk(self, **kwargs):\n\"\"\"Internal helper to generate a RepoThunk for this Source. Takes the\n    same arguments as RepoThunk except for source.\"\"\"\n    return RepoThunk(source=self, **kwargs)\n</code></pre>"},{"location":"sources/core/#codesurvey.sources.Repo","title":"<code>codesurvey.sources.Repo</code>  <code>dataclass</code>","text":"<p>A repository of code that is accessible in a local directory in order to be analyzed.</p> Source code in <code>codesurvey/sources/core.py</code> <pre><code>@dataclass(frozen=True)\nclass Repo:\n\"\"\"A repository of code that is accessible in a local directory in\n    order to be analyzed.\"\"\"\n\n    source: 'Source'\n\"\"\"Source the Repo is provided by.\"\"\"\n\n    key: str\n\"\"\"Unique key of the Repo within its Source.\"\"\"\n\n    # TODO: Change to a pathlib.Path?\n    path: str\n\"\"\"Path to the local directory storing the Repo.\"\"\"\n\n    cleanup: Callable[[], None] = noop\n\"\"\"Function to be called to remove or otherwise cleanup the Repo when\n    analysis of it has finished.\"\"\"\n\n    metadata: Dict[str, Any] = field(default_factory=dict, compare=False)\n\"\"\"Additional properties describing the Repo.\n\n    The metadata structure may vary depending on the type of\n    Source.\n\n    \"\"\"\n\n    def __str__(self):\n        return f'{self.source.name}:{self.key}'\n\n    def __repr__(self):\n        return f'{self.__class__.__name__}({self})'\n</code></pre>"},{"location":"sources/core/#codesurvey.sources.Repo.source","title":"<code>source: Source</code>  <code>instance-attribute</code>","text":"<p>Source the Repo is provided by.</p>"},{"location":"sources/core/#codesurvey.sources.Repo.key","title":"<code>key: str</code>  <code>instance-attribute</code>","text":"<p>Unique key of the Repo within its Source.</p>"},{"location":"sources/core/#codesurvey.sources.Repo.path","title":"<code>path: str</code>  <code>instance-attribute</code>","text":"<p>Path to the local directory storing the Repo.</p>"},{"location":"sources/core/#codesurvey.sources.Repo.cleanup","title":"<code>cleanup: Callable[[], None] = noop</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Function to be called to remove or otherwise cleanup the Repo when analysis of it has finished.</p>"},{"location":"sources/core/#codesurvey.sources.Repo.metadata","title":"<code>metadata: Dict[str, Any] = field(default_factory=dict, compare=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Additional properties describing the Repo.</p> <p>The metadata structure may vary depending on the type of Source.</p>"},{"location":"sources/core/#codesurvey.sources.RepoThunk","title":"<code>codesurvey.sources.RepoThunk</code>  <code>dataclass</code>","text":"<p>An executable task to be run asynchronously to prepare a Repo.</p> Source code in <code>codesurvey/sources/core.py</code> <pre><code>@dataclass(frozen=True)\nclass RepoThunk:\n\"\"\"An executable task to be run asynchronously to prepare a Repo.\"\"\"\n\n    source: 'Source'\n\"\"\"Source the Repo is provided by.\"\"\"\n\n    key: str\n\"\"\"Unique key of the Repo within its Source.\"\"\"\n\n    thunk: Callable[[], Repo]\n\"\"\"Function to be called to prepare and return the Repo.\"\"\"\n\n    def __str__(self):\n        return f'{self.source.name}:{self.key}'\n\n    def __repr__(self):\n        return f'{self.__class__.__name__}({self})'\n</code></pre>"},{"location":"sources/core/#codesurvey.sources.RepoThunk.source","title":"<code>source: Source</code>  <code>instance-attribute</code>","text":"<p>Source the Repo is provided by.</p>"},{"location":"sources/core/#codesurvey.sources.RepoThunk.key","title":"<code>key: str</code>  <code>instance-attribute</code>","text":"<p>Unique key of the Repo within its Source.</p>"},{"location":"sources/core/#codesurvey.sources.RepoThunk.thunk","title":"<code>thunk: Callable[[], Repo]</code>  <code>instance-attribute</code>","text":"<p>Function to be called to prepare and return the Repo.</p>"}]}